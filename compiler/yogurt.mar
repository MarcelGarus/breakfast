| Your Official Graph Using Resolved Types  

import breakfast.mar

struct Yogurt { funs: Map[YogurtSignature, YogurtFun] }
struct YogurtSignature { str: Str }

struct YogurtFun { exprs: Slice[YogurtExpr], body: YogurtBody }
struct YogurtId { int: Int }
struct YogurtBody {
  params: Slice[YogurtId], exprs: Slice[YogurtId], returns: YogurtId
}
struct YogurtExpr { value: YogurtValue, type: YogurtType }

enum YogurtValue {
  param,
  comptime,
  switch_: YogurtSwitch,
  tag: YogurtTag,
  call: YogurtCall,
  cast: YogurtId,
  instruction: YogurtInstruction,
}
struct YogurtSwitch { condition: YogurtId, cases: Map[Str, YogurtBody] }
struct YogurtTag { symbol: Str, args: Slice[YogurtId] }
struct YogurtCall { receiver: YogurtId, args: Slice[YogurtId] }
struct YogurtInstruction { instruction: Instruction, args: Slice[YogurtId] }

enum YogurtType {
  comptime_int: Int,
  int,
  comptime_string: Str,
  string,
  enum_: Map[Str, Slice[YogurtType]],
  fun_: Str,
  never,
}

fun ==(a: YogurtType, b: YogurtType): Bool {
  switch a
  case comptime_int(a)    if b is comptime_int(b)    then a == b else false
  case int(a)             if b is int(b)             then a == b else false
  case comptime_string(a) if b is comptime_string(b) then a == b else false
  case string(a)          if b is string(b)          then a == b else false
  case enum_(a)           if b is enum_(b)           then a == b else false
  case fun_(a)            if b is fun_(b)            then a == b else false
  case never(a)           if b is never(b)           then a == b else false
}
fun hash(hasher: &Hasher, type: YogurtType) {
  switch type
  case comptime_int(int)    { hasher.hash(0) hasher.hash(int) }
  case int                  { hasher.hash(1) }
  case comptime_string(str) { hasher.hash(2) hasher.hash(str) }
  case string               { hasher.hash(3) }
  case enum_(variants)      { hasher.hash(4) }
  case fun_(signature)      { hasher.hash(5) hasher.hash(signature) }
  case never                { hasher.hash(6) }
}

fun get(fun_: YogurtFun, id: YogurtId): YogurtExpr { fun_.exprs.get(id.int) }

fun yogurt_signature(name: Str, arg_types: Slice[YogurtType]): YogurtSignature {
  var b = str_builder().&
  b."{name}"
  for type in arg_types do b." {type}"
  YogurtSignature { str = b.to_str() }
}
fun ==(a: YogurtSignature, b: YogurtSignature): Bool { a.str == b.str }
fun hash(hasher: &Hasher, sig: YogurtSignature) { hasher.hash(sig.str) }

fun write[W](writer: W, yogurt: Yogurt) {
  var first = true
  for fun_ in yogurt.funs do {
    if first then first = false else writer."\n"
    writer."{fun_.key.str}:"
    writer.write(fun_.value.body, fun_.value, 1)
  }
}
fun write[W](writer: W, signature: YogurtSignature) { writer."{signature.str}" }
fun write[W](writer: W, id: YogurtId) { writer."@{id.int}" }
fun write[W](writer: W, body: YogurtBody, fun_: YogurtFun, indentation: Int) {
  for param in body.params do writer." {param}"
  writer."\n"
  for id in body.exprs do {
    var expr = fun_.get(id)
    for i in 0..indentation do writer."  "
    writer."{id}: {expr.type} = "
    writer.write(expr.value, fun_, indentation)
    writer."\n"
  }
  for i in 0..indentation do writer."  "
  writer."{body.returns}"
}
fun write[W](writer: W, value: YogurtValue, fun_: YogurtFun, indentation: Int) {
  switch value
  case comptime writer."comptime"
  case param(param) writer."param {param}"
  case switch_(switch_) {
    writer."switch {switch_.condition}"
    for case_ in switch_.cases do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {case_.key}:"
      writer.write(case_.value, fun_, indentation + 2)
    }
  }
  case tag(tag) {
    writer."tag {tag.symbol}"
    for arg in tag.args do writer." {arg}"
  }
  case call(call) {
    writer."call {call.receiver}"
    for arg in call.args do writer." {arg}"
  }
  case cast(id) writer."cast {id}"
  case instruction(instruction) {
    writer."instruction {instruction.instruction}"
    for arg in instruction.args do writer." {arg}"
  }
}
fun write[W](writer: W, type: YogurtType) {
  switch type
  case comptime_int(int) writer."{int}"
  case int writer."int"
  case comptime_string(string) writer."{string.debug()}"
  case string writer."string"
  case enum_(variants) {
    var first = true
    for variant in variants do {
      if first then first = false else writer." | "
      writer."{variant.key}"
      for arg in variant.value do writer." {arg}"
    }
  }
  case fun_(fun_) writer."fun {fun_}"
  case never writer."never"
}

| Convert Egg to Yogurt  

fun $(value: YogurtValue, type: YogurtType): _ { YogurtExpr { value, type } }

struct YogurtFunBuilder { exprs: Vec[YogurtExpr] }

fun yogurt_fun_builder(): _ { YogurtFunBuilder { exprs = vec[YogurtExpr]() } }
fun push(builder: &YogurtFunBuilder, expr: YogurtExpr): YogurtId {
  var id = YogurtId { int = builder.exprs.len }
  builder.exprs.&.push(expr)
  id
}
fun get(builder: YogurtFunBuilder, id: YogurtId): YogurtExpr {
  builder.exprs.get(id.int)
}

struct YogurtFunCompiler {
  egg: Egg,
  egg_fun: EggFun,
  yogurt: &Yogurt,
  egg_to_yogurt: Map[EggId, YogurtId],
}

fun add_mapping(
  compiler: &YogurtFunCompiler, egg_id: EggId, yogurt_id: YogurtId
) {
  compiler.egg_to_yogurt.&.put(egg_id, yogurt_id)
}
fun lookup(compiler: YogurtFunCompiler, egg_id: EggId): YogurtId {
  compiler.egg_to_yogurt.get(egg_id)
}

fun to_yogurt(egg: Egg): Yogurt {
  var main = egg.defs.get_maybe("main") or panic("no main found")
  var main = main.fun_ or panic("main is not a fun")
  main.body.params.len == 1
    or panic("main takes {main.body.params.len} params instead of 1")
  var yogurt = Yogurt { funs = map[YogurtSignature, YogurtFun]() }
  main.to_yogurt(vec(YogurtType.int).to_slice(), "main", egg, yogurt.&)
  yogurt
}
fun to_yogurt(
  fun_: EggFun, param_types: Slice[YogurtType], name: Str,
  egg: Egg, yogurt: &Yogurt
): YogurtFun {
  var signature = yogurt_signature(name, param_types)

  var builder = yogurt_fun_builder()
  var compiler = YogurtFunCompiler {
    egg, egg_fun = fun_, yogurt, egg_to_yogurt = map[EggId, YogurtId]()
  }
  var body = fun_.body.to_yogurt(param_types, builder.&, compiler.&)
  var fun_ = YogurtFun { exprs = builder.exprs.to_slice(), body = body }

  yogurt.funs.&.put(signature, fun_)
  fun_
}

fun to_yogurt(
  body: EggBody, param_types: Slice[YogurtType],
  builder: &YogurtFunBuilder, compiler: &YogurtFunCompiler
): YogurtBody {
  param_types.len == body.params.len or
    panic("body params len doesn't matche number of param types")
  var params = vec[YogurtId]()
  for i in 0..body.params.len do {
    var egg_id = body.params.get(i)
    var yogurt_id = builder.push(YogurtValue.param $ param_types.get(i))
    params.&.push(yogurt_id)
    compiler.add_mapping(egg_id, yogurt_id)
  }
  var exprs = vec[YogurtId]()
  for egg_id in body.exprs do {
    var expr = compiler.egg_fun.get(egg_id).to_yogurt(builder, compiler)
    var yogurt_id = builder.push(expr)
    exprs.&.push(yogurt_id)
    compiler.add_mapping(egg_id, yogurt_id)
  }
  YogurtBody {
    params = params.to_slice(),
    exprs = exprs.to_slice(),
    returns = compiler.lookup(body.returns),
  }
}
fun to_yogurt(
  expr: EggExpr, builder: &YogurtFunBuilder, compiler: &YogurtFunCompiler
): YogurtExpr {
  switch expr
  case int(int) YogurtValue.comptime $ YogurtType.comptime_int(int)
  case string(string) YogurtValue.comptime $ YogurtType.comptime_string(string)
  case symbol(symbol)
    YogurtValue.comptime
      $ YogurtType.enum_(map(symbol -> empty_slice[YogurtType]()))
  case param todo("implement params in yogurt")
    | compiler.push_param(compiler.parent.params.get(param))
  case global(global) YogurtValue.comptime $ YogurtType.fun_(global)
  case switch_(switch_) {
    var condition = compiler.lookup(switch_.condition)
    var condition_type = builder.get(condition).type
    var condition_variants = condition_type.enum_
      or panic("switched on non-enum")

    | Lower all cases that are used by the condition type.
    var cases = map[Str, YogurtBody]()
    var case_types = vec[YogurtType]()
    for variant in condition_variants do {
      var case_ = switch_.cases.get_maybe(variant.key) or
        panic("switching on {condition_type}, but {variant.key} is not handled")
      variant.value.len == case_.params.len or
        panic("{variant.key} has {variant.value.len} args, but you bind {case_.params.len}")
      var body = case_.to_yogurt(variant.value, builder, compiler)
      cases.&.put(variant.key, body)
      case_types.&.push(builder.get(body.returns).type)
    }

    | Find the common type of all branches.
    var common_type = join(case_types.to_slice())
      or panic("Couldn't join types {case_types}")

    | Add cast expressions where necessary.
    for case_ in cases do {
      var case_type = builder.get(case_.value.returns).type
      if case_type != common_type then {
        eprintln("Insert cast from {case_type} to {common_type}")
        var old_body = case_.value
        var new_exprs = vec[YogurtId]()
        for expr in old_body.exprs do new_exprs.&.push(expr)
        var new_returns = builder.push(YogurtValue.cast(old_body.returns) $ common_type)
        new_exprs.&.push(new_returns)
        cases.&.put(case_.key, YogurtBody {
          params = old_body.params,
          exprs = new_exprs.to_slice(),
          returns = new_returns,
        })
      }
    }

    YogurtValue.switch_(YogurtSwitch { condition, cases }) $ common_type
  }
  case call(call) {
    var receiver = compiler.lookup(call.receiver)

    var args = vec[YogurtId]()
    var arg_types = vec[YogurtType]()
    for arg in call.args do {
      var arg = compiler.lookup(arg)
      var type = builder.get(arg).type
      args.&.push(arg)
      arg_types.&.push(type)
    }
    var args = args.to_slice()
    var arg_types = arg_types.to_slice()

    switch builder.get(receiver).type
    case enum_(variants) {
      variants.size == 1 or panic("called enum with {variants.size} variants")
      var variant = variants.iter().&.next().unwrap()
      variant.value.is_empty() or panic("called symbol that already has values")
      var symbol = variant.key
      YogurtValue.tag(YogurtTag { symbol, args })
        $ YogurtType.enum_(map(symbol -> arg_types))
    }
    case fun_(fun_name) {
      var return_type =
        switch compiler.egg.defs.get(fun_name)
        case fun_(fun_) {
          fun_.body.params.len == args.len or
            panic("called {fun_name} with {args.len} arguments, but it expects 
              '{fun_.body.params.len} parameters")
          var fun_ = fun_.to_yogurt(arg_types, fun_name, compiler.egg,
            compiler.yogurt)
          fun_.exprs.get(fun_.body.returns.int).type
        }
        case builtin(builtin) {
          builtin.num_params() == args.len or
            panic("called {fun_name} with {args.len} arguments, but it expects 
              '{builtin.num_params()} parameters")
          var fun_ = builtin.to_yogurt(arg_types, compiler.egg,
            compiler.yogurt)
          fun_.exprs.get(fun_.body.returns.int).type
        }
        | TODO: don't have global values?
        case value panic("called global value")

      YogurtValue.call(YogurtCall { receiver, args }) $ return_type
    }
    default panic("called {builder.get(receiver).type}")
  }
}

struct YogurtBodyBuilder { parent: &YogurtFunBuilder, body: Vec[YogurtId] }
fun push(body: &YogurtBodyBuilder, expr: YogurtExpr): YogurtId {
  var id = body.parent.&.push(expr)
  body.body.&.push(id)
  id
}
fun get(body: YogurtBodyBuilder, id: YogurtId): YogurtExpr {
  body.parent.get(id)
}
fun to_yogurt(
  builtin: Builtin, arg_types: Slice[YogurtType], egg: Egg, yogurt: &Yogurt
): YogurtFun {
  var signature = yogurt_signature("@builtin_{builtin}", arg_types)

  var fun_builder = yogurt_fun_builder()
  var body = YogurtBodyBuilder {
    parent = fun_builder.&, body = vec[YogurtId]()
  }
  var params = vec[YogurtId]()
  for i in 0..arg_types.len do
    params.&.push(body.parent.&.push(YogurtValue.param $ arg_types.get(i)))
  var params = params.to_slice()
  var returns = builtin.to_yogurt(body.&, params)
  var fun_ = YogurtFun {
    exprs = fun_builder.exprs.to_slice(),
    body = YogurtBody { params, exprs = body.body.to_slice(), returns }
  }

  yogurt.funs.&.put(signature, fun_)
  fun_
}
fun to_yogurt(
  builtin: Builtin, builder: &YogurtBodyBuilder, params: Slice[YogurtId]
): YogurtId {
  switch builtin
  case add {
    var a = params.get(0)
    var b = params.get(1)
    if builder.get(a).type is comptime_int(a) then
      if builder.get(b).type is comptime_int(b) then
        return builder.&.push(YogurtValue.comptime $ YogurtType.comptime_int(a + b))
    var a = a.cast_to_int(builder) or panic("called add with non-int")
    var b = b.cast_to_int(builder) or panic("called add with non-int")
    builder.&.push(YogurtValue.instruction(YogurtInstruction {
      instruction = Instruction.add, args = vec(a, b).to_slice()
    }) $ YogurtType.int)
  }
  case compare {
    var a = params.get(0)
    var b = params.get(1)
    if builder.get(a).type is comptime_int(a) then
      if builder.get(b).type is comptime_int(b) then {
        var symbol =
          switch a <=> b
          case less "Less"
          case equal "Equal"
          case greater "Greater"
        return builder.&.push(
          YogurtValue.comptime
            $ YogurtType.enum_(map(symbol -> empty_slice[YogurtType]()))
        )
      }
    var a = a.cast_to_int(builder) or panic("called add with non-int")
    var b = b.cast_to_int(builder) or panic("called add with non-int")
    builder.&.push(
      YogurtValue.instruction(YogurtInstruction {
        instruction = Instruction.compare, args = vec(a, b).to_slice()
      }) $ YogurtType.enum_(map(
        "Less"    -> empty_slice[YogurtType](),
        "Equal"   -> empty_slice[YogurtType](),
        "Greater" -> empty_slice[YogurtType](),
      ))
    )
  }
  case concat {
    var a = params.get(0)
    var b = params.get(1)
    if builder.get(a).type is comptime_string(a) then
      if builder.get(b).type is comptime_string(b) then
        return builder.&.push(YogurtValue.comptime
          $ YogurtType.comptime_string("{a}{b}"))

    var a = a.cast_to_string(builder) or panic("called add with non-string")
    var b = b.cast_to_string(builder) or panic("called add with non-string")
    builder.&.push(YogurtValue.instruction(YogurtInstruction {
      instruction = Instruction.concat, args = vec(a, b).to_slice()
    }) $ YogurtType.string)
  }
  case type_info {
    var type = builder.get(params.get(0)).type
    var symbol =
      switch type
      case comptime_int "ComptimeInt"
      case int "Int"
      case comptime_string "ComptimeString"
      case string "String"
      case enum_ "Enum"
      case fun_ "Fun"
      case never "Never"
    builder.&.push(
      YogurtValue.comptime
        $ YogurtType.enum_(map(symbol -> empty_slice[YogurtType]()))
    )
  }
  case crash {
    var message = params.get(0).cast_to_string(builder)
      or panic("crash only accepts string messages")
    builder.&.push(
      YogurtValue.instruction(YogurtInstruction {
        instruction = Instruction.crash, args = vec(message).to_slice()
      }) $ YogurtType.never
    )
  }
  default todo("implement builtin {builtin}")
}

fun cast_to_int(id: YogurtId, builder: &YogurtBodyBuilder): Maybe[YogurtId] {
  switch builder.get(id).type
  case int some(id)
  case comptime_int some(builder.push(YogurtValue.cast(id) $ YogurtType.int))
  default none[YogurtId]()
}
fun cast_to_string(id: YogurtId, builder: &YogurtBodyBuilder): Maybe[YogurtId] {
  switch builder.get(id).type
  case string some(id)
  case comptime_string some(builder.push(YogurtValue.cast(id) $ YogurtType.string))
  default none[YogurtId]()
}

fun join(types: Slice[YogurtType]): Maybe[YogurtType] {
  var common = types.get(0)
  for type in types.without_first() do
    common = join(common, type) or return none[YogurtType]()
  some(common)
}
fun join(a: YogurtType, b: YogurtType): Maybe[YogurtType] {
  if a is never then return some(b)
  if b is never then return some(a)

  switch a
  case comptime_int(a_int) {
    switch b
    case comptime_int(b_int) some(if a_int == b_int then a else YogurtType.int)
    case int some(YogurtType.int)
    default none[YogurtType]()
  }
  case int {
    switch b
    case comptime_int some(YogurtType.int)
    case int some(YogurtType.int)
    default none[YogurtType]()
  }
  case comptime_string(a_string) {
    switch b
    case comptime_string(b_string)
      some(if a_string == b_string then a else YogurtType.string)
    case string some(YogurtType.string)
    default none[YogurtType]()
  }
  case string {
    switch b
    case comptime_string some(YogurtType.string)
    case string some(YogurtType.string)
    default none[YogurtType]()
  }
  case enum_(a_variants) {
    switch b
    case enum_(b_variants) {
      var variants = map[Str, Slice[YogurtType]]()
      for variant in a_variants do variants.&.put(variant.key, variant.value)
      for variant in b_variants do {
        if variants.get_maybe(variant.key) is some(a_args) then {
          var args = vec[YogurtType]()
          for both in zip(a_args.iter(), variant.value.iter()) do
            args.&.push(join(both.a, both.b) or return none[YogurtType]())
          variants.&.put(variant.key, args.to_slice())
        } else
          variants.&.put(variant.key, variant.value)
      }
      some(YogurtType.enum_(variants))
    }
    default none[YogurtType]()
  }
  case fun_(a_fun) {
    switch b
    case fun_(b_fun) if a_fun == b_fun then some(a) else none[YogurtType]()
    default none[YogurtType]()
  }
  case never unreachable()
}
