| Your Official Graph Using Resolved Types  

import breakfast.mar

struct Yogurt { funs: Map[YogurtSignature, YogurtFun] }
struct YogurtSignature { str: Str }

struct YogurtFun {
  params: Slice[Str], exprs: Slice[YogurtExpr], body: YogurtBody
}
struct YogurtId { int: Int }
struct YogurtBody { exprs: Slice[YogurtId], returns: YogurtId }
struct YogurtExpr { value: YogurtValue, type: YogurtType }

enum YogurtValue {
  comptime,
  param: Str,
  switch_: YogurtSwitch,
  tag: YogurtTag,
  call: YogurtCall,
  instruction: YogurtInstruction,
}
struct YogurtSwitch { condition: YogurtId, cases: Map[Str, YogurtBody] }
struct YogurtTag { symbol: Str, args: Slice[YogurtId] }
struct YogurtCall { receiver: YogurtId, args: Slice[YogurtId] }
struct YogurtInstruction { instruction: Instruction, args: Slice[YogurtId] }

enum YogurtType {
  comptime_int: Int,
  int,
  comptime_string: Str,
  string,
  enum_: Map[Str, Slice[YogurtType]],
  fun_: Str,
  never,
}

fun get(fun_: YogurtFun, id: YogurtId): YogurtExpr { fun_.exprs.get(id.int) }

fun yogurt_signature(name: Str, arg_types: Slice[YogurtType]): YogurtSignature {
  var b = str_builder().&
  b."{name}"
  for type in arg_types do b." {type}"
  YogurtSignature { str = b.to_str() }
}
fun ==(a: YogurtSignature, b: YogurtSignature): Bool { a.str == b.str }
fun hash(hasher: &Hasher, sig: YogurtSignature) { hasher.hash(sig.str) }

fun write[W](writer: W, yogurt: Yogurt) {
  var first = true
  for fun_ in yogurt.funs do {
    if first then first = false else writer."\n"
    writer."{fun_.key.str}:"
    for param in fun_.value.params do writer." {param}"
    writer."\n"
    writer.write(fun_.value.body, fun_.value, 1)
  }
}
fun write[W](writer: W, signature: YogurtSignature) { writer."{signature.str}" }
fun write[W](writer: W, id: YogurtId) { writer."@{id.int}" }
fun write[W](writer: W, body: YogurtBody, fun_: YogurtFun, indentation: Int) {
  for id in body.exprs do {
    var expr = fun_.get(id)
    for i in 0..indentation do writer."  "
    writer."{id}: {expr.type} = "
    writer.write(expr.value, fun_, indentation)
    writer."\n"
  }
  for i in 0..indentation do writer."  "
  writer."{body.returns}"
}
fun write[W](writer: W, value: YogurtValue, fun_: YogurtFun, indentation: Int) {
  switch value
  case comptime writer."comptime"
  case param(param) writer."param {param}"
  case switch_(switch_) {
    writer."switch {switch_.condition}"
    for case_ in switch_.cases do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {case_.key}:\n"
      writer.write(case_.value, fun_, indentation + 2)
    }
  }
  case tag(tag) {
    writer."tag {tag.symbol}"
    for arg in tag.args do writer." {arg}"
  }
  case call(call) {
    writer."call {call.receiver}"
    for arg in call.args do writer." {arg}"
  }
  case instruction(instruction) {
    writer."instruction {instruction.instruction}"
    for arg in instruction.args do writer." {arg}"
  }
}
fun write[W](writer: W, type: YogurtType) {
  switch type
  case comptime_int(int) writer."{int}"
  case int writer."int"
  case comptime_string(string) writer."{string.debug()}"
  case string writer."string"
  case enum_(variants) {
    var first = true
    for variant in variants do {
      if first then first = false else writer." | "
      writer."{variant.key}"
      for arg in variant.value do writer." {arg}"
    }
  }
  case fun_(fun_) writer."fun {fun_}"
  case never writer."never"
}

| Convert Egg to Yogurt  

fun to_yogurt(egg: Egg): Yogurt {
  var main = egg.defs.get_maybe("main") or panic("no main found")
  var main = main.fun_ or panic("main is not a fun")
  main.params.len == 1
    or panic("main takes {main.params.len} params instead of 1")
  var yogurt = Yogurt { funs = map[YogurtSignature, YogurtFun]() }
  main.to_yogurt(vec(YogurtType.int).to_slice(), "main", egg, yogurt.&)
  yogurt
}
fun to_yogurt(
  fun_: EggFun, args: Slice[YogurtType], name: Str, egg: Egg, yogurt: &Yogurt
): YogurtFun {
  var signature = yogurt_signature(name, args)
  
  var params = map[Str, YogurtType]()
  for i in 0..args.len do params.&.put(fun_.params.get(i), args.get(i))
  var compiler = YogurtFunCompiler {
    egg, egg_fun = fun_, yogurt, params, exprs = vec[YogurtExpr](),
    egg_to_yogurt = map[EggId, YogurtId](),
  }
  var body = compiler.&.body()

  for id in fun_.body.exprs do id.to_yogurt(body.&)

  var fun_ = YogurtFun {
    params = fun_.params,
    exprs = compiler.exprs.to_slice(),
    body = body.finish(fun_.body.returns),
  }
  yogurt.funs.&.put(signature, fun_)
  fun_
}

struct YogurtFunCompiler {
  egg: Egg,
  egg_fun: EggFun,
  yogurt: &Yogurt,
  params: Map[Str, YogurtType],
  exprs: Vec[YogurtExpr],
  egg_to_yogurt: Map[EggId, YogurtId],
}
struct YogurtBodyCompiler {
  parent: &YogurtFunCompiler,
  exprs: Vec[YogurtId],
}

fun body(parent: &YogurtFunCompiler): YogurtBodyCompiler {
  YogurtBodyCompiler { parent, exprs = vec[YogurtId]() }
}
fun push(compiler: &YogurtBodyCompiler, expr: YogurtExpr): YogurtId {
  var id = YogurtId { int = compiler.parent.exprs.len }
  compiler.parent.exprs.&.push(expr)
  compiler.exprs.&.push(id)
  id
}
fun get(compiler: YogurtBodyCompiler, id: YogurtId): YogurtExpr {
  compiler.parent.exprs.get(id.int)
}
fun lookup(compiler: YogurtBodyCompiler, egg_id: EggId): YogurtId {
  compiler.parent.egg_to_yogurt.get(egg_id)
}
fun finish(compiler: YogurtBodyCompiler, id: EggId): YogurtBody {
  YogurtBody {
    exprs = compiler.exprs.to_slice(),
    returns = compiler.parent.egg_to_yogurt.get(id),
  }
}

fun $(value: YogurtValue, type: YogurtType): _ { YogurtExpr { value, type } }

fun to_yogurt(egg_id: EggId, compiler: &YogurtBodyCompiler): YogurtId {
  var yogurt_id = compiler.parent.egg_fun.get(egg_id).to_yogurt(compiler)
  compiler.parent.egg_to_yogurt.&.put(egg_id, yogurt_id)
  yogurt_id
}
fun to_yogurt(expr: EggExpr, compiler: &YogurtBodyCompiler): YogurtId {
  switch expr
  case int(int)
    compiler.push(YogurtValue.comptime $ YogurtType.comptime_int(int))
  case string(string)
    compiler.push(YogurtValue.comptime $ YogurtType.comptime_string(string))
  case symbol(symbol)
    compiler.push(YogurtValue.comptime
      $ YogurtType.enum_(map(symbol -> empty_slice[YogurtType]())))
  case param(param)
    compiler.push(YogurtValue.param(param) $ compiler.parent.params.get(param))
  case global(global) compiler.push(
    YogurtValue.comptime $ YogurtType.fun_(global))
  case switch_(switch_) {
    var condition = compiler.lookup(switch_.condition)
    var condition_type = compiler.get(condition).type
    var condition_variants = condition_type.enum_
      or panic("switched on non-enum")

    var cases = map[Str, YogurtBody]()
    var case_types = vec[YogurtType]()
    for variant in condition_variants do {
      var case_ = switch_.cases.get_maybe(variant.key) or
        panic("switching on {condition_type}, but {variant.key} is not handled")
      var case_compiler = compiler.parent.&.body()
      for id in case_.exprs do id.to_yogurt(case_compiler.&)
      var body = case_compiler.finish(case_.returns)
      cases.&.put(variant.key, body)
      case_types.&.push(compiler.get(body.returns).type)
    }
    var type = join(case_types.to_slice())
      or panic("Couldn't join types {case_types}")
    compiler.push(
      YogurtValue.switch_(YogurtSwitch { condition, cases }) $ type)
  }
  case call(call) {
    var receiver = compiler.lookup(call.receiver)

    var args = vec[YogurtId]()
    var arg_types = vec[YogurtType]()
    for arg in call.args do {
      var arg = compiler.lookup(arg)
      var type = compiler.get(arg).type
      args.&.push(arg)
      arg_types.&.push(type)
    }
    var args = args.to_slice()
    var arg_types = arg_types.to_slice()

    switch compiler.get(receiver).type
    case enum_(variants) {
      variants.size == 1 or panic("called enum with {variants.size} variants")
      var variant = variants.iter().&.next().unwrap()
      variant.value.is_empty() or panic("called symbol that already has values")
      var symbol = variant.key
      compiler.push(
        YogurtValue.tag(YogurtTag { symbol, args })
          $ YogurtType.enum_(map(symbol -> arg_types))
      )
    }
    case fun_(fun_name) {
      var return_type =
        switch compiler.parent.egg.defs.get(fun_name)
        case fun_(fun_) {
          fun_.params.len == args.len or
            panic("called {fun_name} with {args.len} arguments, but it expects 
              '{fun_.params.len} parameters")
          var fun_ = fun_.to_yogurt(arg_types, fun_name, compiler.parent.egg,
            compiler.parent.yogurt)
          fun_.exprs.get(fun_.body.returns.int).type
        }
        case builtin(builtin) {
          builtin.num_params() == args.len or
            panic("called {fun_name} with {args.len} arguments, but it expects 
              '{builtin.num_params()} parameters")
          var fun_ = builtin.to_yogurt(arg_types, compiler.parent.egg,
            compiler.parent.yogurt)
          fun_.exprs.get(fun_.body.returns.int).type
        }
        | TODO: don't have global values?
        case value panic("called global value")

      compiler.push(
        YogurtValue.call(YogurtCall { receiver, args }) $ return_type)
    }
    default panic("called {compiler.get(receiver).type}")
  }
}

struct YogurtBodyBuilder {
  exprs: Vec[YogurtExpr],
  body: Vec[YogurtId],
}
fun push(body: &YogurtBodyBuilder, expr: YogurtExpr): YogurtId {
  var id = YogurtId { int = body.exprs.len }
  body.exprs.&.push(expr)
  body.body.&.push(id)
  id
}
fun to_yogurt(
  builtin: Builtin, arg_types: Slice[YogurtType], egg: Egg, yogurt: &Yogurt
): YogurtFun {
  var signature = yogurt_signature("@builtin_{builtin}", arg_types)

  var body = YogurtBodyBuilder {
    exprs = vec[YogurtExpr](),
    body = vec[YogurtId](),
  }

  var args = vec[YogurtId]()
  for i in 0..arg_types.len do
    args.&.push(body.&.push(YogurtValue.param("arg_{i}") $ arg_types.get(i)))
  var args = args.to_slice()

  var returns = builtin.to_yogurt(body.&, args, arg_types)

  var fun_ = YogurtFun {
    params = {
      var vec = vec[Str]()
      for i in 0..arg_types.len do vec.&.push("arg_{i}")
      vec.to_slice()
    },
    exprs = body.exprs.to_slice(),
    body = YogurtBody { exprs = body.body.to_slice(), returns }
  }
  yogurt.funs.&.put(signature, fun_)
  fun_
}
fun to_yogurt(
  builtin: Builtin, body: &YogurtBodyBuilder,
  args: Slice[YogurtId], arg_types: Slice[YogurtType],
): YogurtId {
  switch builtin
  case add {
    var a_type = arg_types.get(0)
    var b_type = arg_types.get(1)
    if a_type is comptime_int(a) then if b_type is comptime_int(b) then {
      return body.&.push(YogurtValue.comptime $ YogurtType.comptime_int(a + b))
    }
    a_type.is_inty() or panic("called add with non-int")
    b_type.is_inty() or panic("called add with non-int")
    body.&.push(YogurtValue.instruction(YogurtInstruction {
      instruction = Instruction.add, args
    }) $ YogurtType.int)
  }
  case compare {
    var a_type = arg_types.get(0)
    var b_type = arg_types.get(1)
    if a_type is comptime_int(a) then if b_type is comptime_int(b) then {
      var symbol =
        switch a <=> b
        case less "Less"
        case equal "Equal"
        case greater "Greater"
      return body.&.push(
        YogurtValue.comptime
          $ YogurtType.enum_(map(symbol -> empty_slice[YogurtType]()))
      )
    }
    a_type.is_inty() or panic("called compare with non-int")
    b_type.is_inty() or panic("called compare with non-int")
    body.&.push(
      YogurtValue.instruction(YogurtInstruction {
        instruction = Instruction.compare, args
      }) $ YogurtType.enum_(map(
        "Less"    -> empty_slice[YogurtType](),
        "Equal"   -> empty_slice[YogurtType](),
        "Greater" -> empty_slice[YogurtType](),
      ))
    )
  }
  case concat {
    var a_type = arg_types.get(0)
    var b_type = arg_types.get(1)
    if a_type is comptime_string(a) then if b_type is comptime_string(b) then {
      return body.&.push(YogurtValue.comptime $ YogurtType.comptime_string("{a}{b}"))
    }
    a_type.is_stringy() or panic("called concat with non-string")
    b_type.is_stringy() or panic("called concat with non-string")
    body.&.push(YogurtValue.instruction(YogurtInstruction {
      instruction = Instruction.concat, args
    }) $ YogurtType.string)
  }
  case type_info {
    var type = arg_types.get(0)
    var symbol =
      switch type
      case comptime_int "ComptimeInt"
      case int "Int"
      case comptime_string "ComptimeString"
      case string "String"
      case enum_ "Enum"
      case fun_ "Fun"
      case never "Never"
    body.&.push(
      YogurtValue.comptime
        $ YogurtType.enum_(map(symbol -> empty_slice[YogurtType]()))
    )
  }
  case crash {
    | TODO: check it's a string
    body.&.push(
      YogurtValue.instruction(YogurtInstruction {
        instruction = Instruction.crash, args
      }) $ YogurtType.never
    )
  }
  default todo("implement builtin {builtin}")
}

fun is_inty(type: YogurtType): Bool { {type is comptime_int} or {type is int} }
fun is_stringy(type: YogurtType): Bool { {type is comptime_string} or {type is string} }

fun join(types: Slice[YogurtType]): Maybe[YogurtType] {
  var common = types.get(0)
  for type in types.without_first() do
    common = join(common, type) or return none[YogurtType]()
  some(common)
}
fun join(a: YogurtType, b: YogurtType): Maybe[YogurtType] {
  if a is never then return some(b)
  if b is never then return some(a)

  switch a
  case comptime_int(a_int) {
    switch b
    case comptime_int(b_int) some(if a_int == b_int then a else YogurtType.int)
    case int some(YogurtType.int)
    default none[YogurtType]()
  }
  case int {
    switch b
    case comptime_int some(YogurtType.int)
    case int some(YogurtType.int)
    default none[YogurtType]()
  }
  case comptime_string(a_string) {
    switch b
    case comptime_string(b_string)
      some(if a_string == b_string then a else YogurtType.string)
    case string some(YogurtType.string)
    default none[YogurtType]()
  }
  case string {
    switch b
    case comptime_string some(YogurtType.string)
    case string some(YogurtType.string)
    default none[YogurtType]()
  }
  case enum_(a_variants) {
    switch b
    case enum_(b_variants) {
      var variants = map[Str, Slice[YogurtType]]()
      for variant in a_variants do variants.&.put(variant.key, variant.value)
      for variant in b_variants do {
        if variants.get_maybe(variant.key) is some(a_args) then {
          var args = vec[YogurtType]()
          for both in zip(a_args.iter(), variant.value.iter()) do
            args.&.push(join(both.a, both.b) or return none[YogurtType]())
          variants.&.put(variant.key, args.to_slice())
        } else
          variants.&.put(variant.key, variant.value)
      }
      some(YogurtType.enum_(variants))
    }
    default none[YogurtType]()
  }
  case fun_(a_fun) {
    switch b
    case fun_(b_fun) if a_fun == b_fun then some(a) else none[YogurtType]()
    default none[YogurtType]()
  }
  case never unreachable()
}
