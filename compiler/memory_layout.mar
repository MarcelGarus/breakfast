import plum.mar

struct MemoryLayout { size: Int, alignment: Int }

struct AggregateLayout {
  size: Int, alignment: Int,
  parts: Slice[AggregatePart],
  field_to_offset: Map[Int, Int],
}
enum AggregatePart { padding: Int, field: Int }

| Is deterministic.
fun layout_aggregate(fields: Slice[MemoryLayout]): AggregateLayout {
  | TODO: make efficient by reordering fields

  var size = 0
  var alignment = 1
  var parts = list[AggregatePart]()
  var field_to_offset = map[Int, Int]()

  for field in fields.iter().enumerate() do {
    var index = field.index
    var field = field.item

    var size_before_padding = size
    size = size.round_up_to_multiple_of(field.alignment)
    if size_before_padding != size then
      parts.&.push(AggregatePart.padding(size - size_before_padding))

    field_to_offset.&.put(index, size)
    parts.&.push(AggregatePart.field(index))
    size = size + field.size

    alignment = max(alignment, field.alignment)
  }
  AggregateLayout {
    size, alignment, parts = parts.to_slice(), field_to_offset = field_to_offset
  }
}

| Layouting arbitrary types  

fun memory_layout(type: PlumType): MemoryLayout {
  switch type
  case primitive(name) {
    if      name == "Int"    then MemoryLayout { size = 8,  alignment = 8 }
    else if name == "String" then MemoryLayout { size = 16, alignment = 8 }
    else todo("handle mem layouting primitive type {name}")
  }
  case never MemoryLayout { size = 0, alignment = 0 }
  case struct_ {
    var layout = type.memory_layout_struct()
    MemoryLayout { size = layout.size, alignment = layout.alignment }
  }
  case enum_(enum_) {
    var layout = type.memory_layout_enum()
    MemoryLayout { size = layout.size, alignment = layout.alignment }
  }
  case lambda(lambda) todo()
  case recursive unreachable()
}

| Layouting function parameters  

struct ParamsLayout {
  size: Int, alignment: Int,
  parts: Slice[ParamsPart],
  param_to_offset: Map[Int, Int],
}
enum ParamsPart { param: Int, padding: Int }

fun memory_layout_params(params: Slice[PlumType]): ParamsLayout {
  var layouts = list[MemoryLayout]()
  for param in params do
    layouts.&.push(param.memory_layout())
  var layout = layouts.to_slice().layout_aggregate()

  var parts = list[ParamsPart]()
  for part in layout.parts do
    parts.&.push(
      switch part
      case padding(amount) ParamsPart.padding(amount)
      case field(index) ParamsPart.param(index)
    )

  ParamsLayout {
    size = layout.size, alignment = layout.alignment,
    parts = parts.to_slice(),
    param_to_offset = layout.field_to_offset,
  }
}

| Layouting structs  

struct StructLayout {
  size: Int, alignment: Int,
  parts: Slice[StructPart],
  field_to_offset: Map[String, Int],
}
enum StructPart { field: String, padding: Int }

fun memory_layout_struct(type: PlumType): StructLayout {
  var fields = type.struct_.unwrap()

  | Order fields by name so that the memory layout is deterministic, even if
  | multiple definitions of the struct use different orderings.
  var field_names = list[String]()
  for field in fields do field_names.&.push(field.key)
  field_names.to_slice().&.sort()

  | Layout the fields.
  var field_layouts = list[MemoryLayout]()
  for name in field_names do
    field_layouts.&.push(fields.get(name).memory_layout())
  var field_layouts = field_layouts.to_slice()

  | Layout the fields efficiently.
  var layout = field_layouts.layout_aggregate()

  | Map AggregateLayout to StructLayout.
  var parts = list[StructPart]()
  for part in layout.parts do
    parts.&.push(
      switch part
      case padding(amount) StructPart.padding(amount)
      case field(index) StructPart.field(field_names.get(index))
    )
  var field_to_offset = map[String, Int]()
  for entry in layout.field_to_offset do
    field_to_offset.&.put(field_names.get(entry.key), entry.value)
  StructLayout {
    size = layout.size, alignment = layout.alignment,
    parts = parts.to_slice(), field_to_offset,
  }
}

| Layouting enums  

struct EnumLayout {
  size: Int,
  alignment: Int,
  variants: Map[String, VariantLayout],
  tag_offset: Int,
  tag_to_variant: Map[Byte, String],
}
struct VariantLayout {
  parts: Slice[VariantPart],
  payload_offsets: Slice[Int],
}
enum VariantPart { padding: Int, payload: Int, tag: Byte }

fun memory_layout_enum(type: PlumType): EnumLayout {
  var variants = type.enum_.unwrap()

  | Order variants by name so that the tags are chosen deterministically, even
  | if multiple definitions of the enum use different orderings.
  var variant_names = list[String]()
  for variant in variants do variant_names.&.push(variant.key)
  variant_names.to_slice().&.sort()

  var tag_to_variant = map[Byte, String]()
  for variant in variant_names.iter().enumerate() do
    tag_to_variant.&.put(variant.index.lower_byte(), variant.item)

  var variant_to_tag = map[String, Byte]()
  for variant in variant_names.iter().enumerate() do
    variant_to_tag.&.put(variant.item, variant.index.lower_byte())

  var payload_aggregates = map[String, AggregateLayout]()
  var max_payload_size = 0
  var max_payload_alignment = 1

  for variant in variants do {
    | Layout the args.
    var arg_layouts = list[MemoryLayout]()
    for arg in variant.value do
      arg_layouts.&.push(arg.memory_layout())
    var arg_layouts = arg_layouts.to_slice()

    | Layout the args efficiently.
    var layout = arg_layouts.layout_aggregate()

    | Update the global payload size and alignment.
    max_payload_size = max(max_payload_size, layout.size)
    max_payload_alignment = max(max_payload_alignment, layout.alignment)

    payload_aggregates.&.put(variant.key, layout)
  }

  var variant_layouts = map[String, VariantLayout]()

  for variant in variants do {
    var layout = payload_aggregates.get(variant.key)

    | Map parts.
    var parts = list[VariantPart]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case padding(amount) VariantPart.padding(amount)
        case field(index) VariantPart.payload(index)
      )

    | Add padding so that all payloads have the same size.
    var needed_padding = max_payload_size - layout.size
    if needed_padding > 0 then parts.&.push(VariantPart.padding(needed_padding))

    | Add tag.
    parts.&.push(VariantPart.tag(variant_to_tag.get(variant.key)))

    | Map offsets.
    var payload_offsets = uninitialized_slice[Int](variant.value.len)
    for entry in layout.field_to_offset do
      payload_offsets.&.set(entry.key, entry.value)

    | Construct VariantLayout.
    variant_layouts.&.put(variant.key, VariantLayout {
      parts = parts.to_slice(), payload_offsets,
    })
  }

  EnumLayout {
    size = max_payload_size + 1,
    alignment = max_payload_alignment,
    variants = variant_layouts,
    tag_offset = max_payload_size,
    tag_to_variant,
  }
}

fun is_recursive(type: PlumType, depth: Int): Bool {
  switch type
  case primitive false
  case never false
  case struct_(struct_) {
    for field in struct_ do
      if field.value.is_recursive(depth + 1) then return true
    false
  }
  case enum_(enum_) {
    for variant in enum_ do
      for arg in variant.value do
        if arg.is_recursive(depth + 1) then return true
    false
  }
  case lambda(lambda) false
  case recursive(level) level >= depth
}
