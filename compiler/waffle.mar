| Well-Aligned Form of Fixed-Layout Expressions  
|
| This compiler stage is pretty low-level. It's no longer graph based, but
| mainly tree based â€“ as a preparation for lowering to stack-based byte code.
| Types no longer exist. Instead, each expression corresponds to a slice of
| bytes. For expressions to be compatible (such as branches of a switch), they
| just have to have the same length.
| Structs have been converted into runs of expressions (shown using curly
| braces). Enums have been converted into tagged unions.
|
| TODO: heap
|
| main Int: @0:word
|   | Creating and accessing a struct.
|   | foo = & x: @0 y: 42   | & y: Int x: Int
|   | foo.y
|   @1 = {@0 42:word}.member(8)
|   | Creating and switching on an enum.
|   | foo: Bool = True
|   | foo
|   | % True: Some 5
|   |   False: None
|   @2 = {1:byte}.member(0) %
|     0 -> {padding(8) 0:byte}
|     1 -> {5:word 1:byte}

import plum.mar

struct Waffle { funs: Map[WaffleSignature, WaffleFun] }
struct WaffleSignature { string: String }

| Functions here don't explicitly contain parameters. Instead, the local @0
| represents the parameters. @0 is guaranteed to exist and be on the stack when
| the function starts executing.
struct WaffleFun { locals: Slice[WaffleExpr], body: WaffleBody }
struct WaffleId { index: Int } | index into the WaffleFun's locals
struct WaffleBody { locals: Slice[WaffleId], returns: WaffleExpr }

struct WaffleExpr { size: Int, alignment: Int, kind: WaffleExprKind }
enum WaffleExprKind {
  param,
  padding: Int,
  byte: Byte, | 8 bits
  word: Int,  | 64 bits
  local: WaffleId,
  aggregate: Slice[WaffleExpr],
  member: WaffleMember,
  switch_: WaffleSwitch,
  call: WaffleCall,
  add_64: &WaffleExpr,
  sub_64: &WaffleExpr,
  mul_64: &WaffleExpr,
  div_64: &WaffleExpr,
  mod_64: &WaffleExpr,
  and_64: &WaffleExpr,
  or_64: &WaffleExpr,
  xor_64: &WaffleExpr,
  crash: &WaffleExpr,
}
struct WaffleMember { of: &WaffleExpr, offset: Int }
struct WaffleSwitch { byte: &WaffleExpr, cases: Slice[WaffleBody] }
struct WaffleCall { function: WaffleSignature, args: &WaffleExpr }

fun waffle_padding(amount: Int): WaffleExpr {
  WaffleExpr {
    size = amount, alignment = 1, kind = WaffleExprKind.padding(amount)
  }
}
fun waffle_byte(byte: Byte): WaffleExpr {
  WaffleExpr { size = 1, alignment = 1, kind = WaffleExprKind.byte(byte) }
}
fun waffle_word(word: Int): WaffleExpr {
  WaffleExpr { size = 8, alignment = 8, kind = WaffleExprKind.word(word) }
}
fun waffle_local(id: WaffleId, size: Int, alignment: Int): WaffleExpr {
  WaffleExpr { size, alignment, kind = WaffleExprKind.local(id) }
}
fun waffle_aggregate(fields: Slice[WaffleExpr]): WaffleExpr {
  var size = 0
  var alignment = 1
  for field in fields do {
    size.is_multiple_of(field.alignment) or
      panic("badly aligned field in aggregate")
    size = size + field.size
    alignment = max(alignment, field.alignment)
  }
  WaffleExpr { size, alignment, kind = WaffleExprKind.aggregate(fields) }
}
fun waffle_member(
  of: WaffleExpr, offset: Int, size: Int, alignment: Int
): WaffleExpr {
  offset >= 0 or panic("negative offset")
  offset + size <= of.size or panic("offset too big")
  WaffleExpr {
    size, alignment,
    kind = WaffleExprKind.member(WaffleMember { of = of.put_on_heap(), offset })
  }
}
fun waffle_switch(byte: WaffleExpr, cases: Slice[WaffleBody]): WaffleExpr {
  byte.size == 1 or panic("switch byte has invalid size")
  byte.alignment == 1 or panic("switch byte has invalid alignment")
  cases.is_not_empty() or panic("switch with no cases")
  var size = cases.get(0).returns.size
  var alignment = 1
  for case_ in cases do {
    size == case_.returns.size or panic("switch cases have different sizes")
    alignment = max(alignment, case_.returns.alignment)
  }
  WaffleExpr {
    size, alignment,
    kind = WaffleExprKind.switch_(WaffleSwitch { byte = byte.put_on_heap(), cases })
  }
}
| The size and alignment are of the returned value, not the arguments.
fun waffle_call(
  function: WaffleSignature, args: WaffleExpr, size: Int, alignment: Int
): WaffleExpr {
  WaffleExpr {
    size, alignment,
    kind = WaffleExprKind.call(WaffleCall { function, args = args.put_on_heap() })
  }
}
fun is_word(expr: WaffleExpr): Bool {
  expr.size == 8 and expr.alignment == 8
}
fun waffle_int_operands(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  left.is_word() or panic("int operands, but left is not an int 64")
  right.is_word() or panic("int operands, but right is not an int 64")
  waffle_aggregate(list(left, right).to_slice())
}
fun waffle_add_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.add_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_sub_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.sub_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_mul_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.mul_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_div_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.div_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_mod_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.mod_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_and_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.and_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_or_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.or_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_xor_64(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.xor_64(waffle_int_operands(left, right).put_on_heap()),
  }
}
fun waffle_crash(message_ptr: WaffleExpr, message_len: WaffleExpr): WaffleExpr {
  message_ptr.is_word() or panic("crash, but message_ptr is not a word")
  message_len.is_word() or panic("crash, but message_len is not a word")
  WaffleExpr {
    size = 8, alignment = 8,
    kind = WaffleExprKind.crash(
      waffle_aggregate(list(message_ptr, message_len).to_slice()).put_on_heap()
    ),
  }
}
struct WaffleFunBuilder { locals: List[WaffleExpr] }
struct WaffleBodyBuilder {
  local_exprs: &List[WaffleExpr], local_ids: List[WaffleId], alignment: Int
}
fun waffle_fun_builder(args_size: Int, args_alignment: Int): WaffleFunBuilder {
  WaffleFunBuilder {
    locals = list(WaffleExpr {
      size = args_size, alignment = args_alignment,
      kind = WaffleExprKind.param,
    })
  }
}
fun body(builder: &WaffleFunBuilder): WaffleBodyBuilder {
  WaffleBodyBuilder {
    local_exprs = builder.locals.&, local_ids = list[WaffleId](), alignment = 1
  }
}
fun local(builder: &WaffleBodyBuilder, expr: WaffleExpr): WaffleExpr {
  var id = WaffleId { index = builder.local_exprs.len }
  builder.local_exprs.push(expr)
  builder.local_ids.&.push(id)
  builder.alignment = max(builder.alignment, expr.alignment)
  waffle_local(id, expr.size, expr.alignment)
}
fun returns(builder: WaffleBodyBuilder, expr: WaffleExpr): WaffleBody {
  WaffleBody { locals = builder.local_ids.to_slice(), returns = expr }
}
fun finish(builder: WaffleFunBuilder, body: WaffleBody): WaffleFun {
  WaffleFun { locals = builder.locals.to_slice(), body }
}

fun get(fun_: WaffleFun, id: WaffleId): WaffleExpr { fun_.locals.get(id.index) }

fun ==(a: WaffleId, b: WaffleId): Bool { a.index == b.index }
fun hash(hasher: &Hasher, id: WaffleId) { hasher.hash(id.index) }

| fun waffle_signature(
|   name: String, params: Slice[WaffleParam]
| ): WaffleSignature {
|   var b = string_builder().&
|   b."{name}"
|   for param in params do
|     b." {switch param case comptime(val) "{val}:{val.type}" case runtime(type) "{type}"}"
|   WaffleSignature { str = b.to_string() }
| }
fun ==(a: WaffleSignature, b: WaffleSignature): Bool { a.string == b.string }
fun hash(hasher: &Hasher, sig: WaffleSignature) { hasher.hash(sig.string) }


fun write[W](writer: W, waffle: Waffle) {
  var first = true
  for fun_ in waffle.funs do {
    if first then first = false else writer."\n"
    writer."{fun_.key}: (@0 contains args)\n"
    writer.write(fun_.value.body, fun_.value, 1)
  }
}
fun write[W](writer: W, signature: WaffleSignature) {
  writer."{signature.string}"
}
fun write[W](writer: W, id: WaffleId) { writer."@{id.index}" }
fun write[W](writer: W, body: WaffleBody, fun_: WaffleFun, indentation: Int) {
  for id in body.locals do {
    var expr = fun_.get(id)
    for i in 0..indentation do writer."  "
    writer."{id} = "
    writer.write(expr, fun_, indentation)
    writer."\n"
  }
  for i in 0..indentation do writer."  "
  writer.write(body.returns, fun_, indentation)
}
fun write[W](
  writer: W, expr: WaffleExpr, fun_: WaffleFun, indentation: Int
) {
  switch expr.kind
  case param unreachable()
  case padding(amount) writer."padding({amount})"
  case byte(byte) writer."{byte}:1"
  case word(word) writer."{word}:8"
  case local(id) writer."{id}"
  case aggregate(aggregate) {
    writer."\{"
    var first = true
    for field in aggregate do {
      if first then first = false else writer.", "
      writer.write(field, fun_, indentation + 1)
    }
    writer."\}"
  }
  case member(member) {
    writer.write(member.of.*, fun_, indentation)
    writer.".{member.offset}:{expr.size}"
  }
  case switch_(switch_) {
    writer.write(switch_.byte.*, fun_, indentation)
    writer." %"
    for case_ in switch_.cases.iter().enumerate() do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {case_.index} -> \{"
      writer."\n"
      writer.write(case_.item, fun_, indentation + 2)
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  \}"
    }
  }
  case call(call) {
    writer."({call.function} "
    writer.write(call.args.*, fun_, indentation)
    writer.")"
  }
  case add_64(ops) {
    writer."(add_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case sub_64(ops) {
    writer."(sub_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case mul_64(ops) {
    writer."(mul_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case div_64(ops) {
    writer."(div_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case mod_64(ops) {
    writer."(mod_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case and_64(ops) {
    writer."(and_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case or_64(ops) {
    writer."(or_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case xor_64(ops) {
    writer."(xor_64 "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
  case crash(ops) {
    writer."(crash "
    writer.write(ops.*, fun_, indentation)
    writer.")"
  }
}

| Converting Yogurt to Waffle  

fun to_waffle(value: YogurtValue): WaffleExpr {
  switch value.kind
  case int(int) waffle_word(int)
  case string(string)
    waffle_aggregate(list(
      waffle_word(string.data.to_int()),
      waffle_word(string.len),
    ).to_slice())
  case struct_(fields) {
    var layout = value.type.memory_layout_struct()
    var parts = list[WaffleExpr]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case padding(amount) waffle_padding(amount)
        case field(name) fields.get(name).to_waffle()
      )
    waffle_aggregate(parts.to_slice())
  }
  case tag(tag) {
    var layout = value.type.memory_layout_enum().variants.get(tag.symbol)
    var parts = list[WaffleExpr]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case padding(amount) waffle_padding(amount)
        case payload(index) tag.payloads.get(index).to_waffle()
        case tag(byte) waffle_byte(byte)
      )
    waffle_aggregate(parts.to_slice())
  }
  case lambda todo()
  case type todo()
}

fun to_waffle(
  expr: YogurtExpr,
  fun_: YogurtFun, fun_builder: &WaffleFunBuilder,
  yogurt_id_to_waffle_expr: &Map[YogurtId, WaffleExpr],
  yogurt: Yogurt,
): WaffleExpr {
  switch expr.op
  case param unreachable()
  case uninitialized unreachable()
  case comptime(value) {
    value.to_waffle()
  }
  case struct_(struct_) {
    var layout = expr.type.memory_layout_struct()
    var parts = list[WaffleExpr]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case field(name) yogurt_id_to_waffle_expr.get(struct_.get(name))
        case padding(amount) waffle_padding(amount)
      )
    waffle_aggregate(parts.to_slice())
  }
  case member(member) {
    var struct_layout = fun_.get(member.of).type.memory_layout_struct()
    var field_layout = expr.type.memory_layout()
    yogurt_id_to_waffle_expr.get(member.of).waffle_member(
      struct_layout.field_to_offset.get(member.name),
      field_layout.size,
      field_layout.alignment,
    )
  }
  | TODO: terminology: tag vs. variant
  case tag(tag) {
    var layout = expr.type.memory_layout_enum().variants.get(tag.symbol)
    var parts = list[WaffleExpr]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case padding(amount) waffle_padding(amount)
        case payload(index) yogurt_id_to_waffle_expr.get(tag.payloads.get(index))
        case tag(byte) waffle_byte(byte)
      )
    waffle_aggregate(parts.to_slice())
  }
  case switch_(switch_) {
    var condition = yogurt_id_to_waffle_expr.get(switch_.condition)

    var layout = fun_.get(switch_.condition).type.memory_layout_enum()

    for variant_layout in layout.variants do {
      var payloads = switch_.cases.get(variant_layout.key).params
      for payload in payloads.iter().enumerate() do {
        var id = payload.item
        var payload_layout = fun_.get(id).type.memory_layout()
        yogurt_id_to_waffle_expr.put(
          id,
          condition.waffle_member(
            variant_layout.value.payload_offsets.get(payload.index),
            payload_layout.size, payload_layout.alignment,
          )
        )
      }
    }

    var cases = uninitialized_slice[WaffleBody](layout.tag_to_variant.size)
    for entry in layout.tag_to_variant do
      cases.&.set(
        entry.key.to_int(),
        switch_.cases.get(entry.value)
          .to_waffle(fun_, fun_builder, yogurt_id_to_waffle_expr, yogurt)
      )

    waffle_switch(
      condition.waffle_member(layout.tag_offset, 1, 1),
      cases,
    )
  }
  case lambda(lambda) todo("implement lambda")
  case lambda_call(call) todo("implement lambda call")
  case call(call) {
    var arg_types = list[PlumType]()
    for arg in call.args do arg_types.&.push(fun_.get(arg).type)
    var arg_layout = arg_types.to_slice().memory_layout_params()

    var parts = list[WaffleExpr]()
    for part in arg_layout.parts do
      parts.&.push(
        switch part
        case padding(amount) waffle_padding(amount)
        case param(index) yogurt_id_to_waffle_expr.get(call.args.get(index))
      )
    var args = waffle_aggregate(parts.to_slice())

    var return_layout = yogurt.funs.get(call.function).return_type().memory_layout()

    waffle_call(
      WaffleSignature { string = call.function.str }, args,
      return_layout.size, return_layout.alignment,
    )
  }
  case instruction(instructions) todo("implement instruction")
}


fun to_waffle(
  body: YogurtBody,
  fun_: YogurtFun, fun_builder: &WaffleFunBuilder,
  yogurt_id_to_waffle_expr: &Map[YogurtId, WaffleExpr],
  yogurt: Yogurt,
): WaffleBody {
  var builder = fun_builder.&.body()
  for id in body.exprs do {
    var expr = builder.&.local(
      fun_.get(id).to_waffle(fun_, fun_builder, yogurt_id_to_waffle_expr, yogurt)
    )
    yogurt_id_to_waffle_expr.&.put(id, expr)
  }
  builder.returns(yogurt_id_to_waffle_expr.get(body.returns))
}

fun to_waffle(fun_: YogurtFun, yogurt: Yogurt): WaffleFun {
  var params = list[YogurtId]()
  for param in fun_.body.params do params.&.push(param)
  var params = params.to_slice()

  var param_types = list[PlumType]()
  for param in params do param_types.&.push(fun_.get(param).type)
  var param_layout = param_types.to_slice().memory_layout_params()

  var fun_builder = waffle_fun_builder(param_layout.size, param_layout.alignment)
  var param_aggregate = waffle_local(
    WaffleId { index = 0 }, param_layout.size, param_layout.alignment
  )
  var yogurt_id_to_waffle_expr = map[YogurtId, WaffleExpr]()
  for param in params.iter().enumerate() do {
    var layout = fun_.get(param.item).type.memory_layout()
    yogurt_id_to_waffle_expr.&.put(
      param.item,
      param_aggregate.waffle_member(
        param_layout.param_to_offset.get(param.index),
        layout.size, layout.alignment,
      )
    )
  }

  var body = fun_.body.to_waffle(
    fun_, fun_builder.&, yogurt_id_to_waffle_expr.&, yogurt
  )
  fun_builder.finish(body)
}

fun to_waffle(yogurt: Yogurt): Waffle {
  var funs = map[WaffleSignature, WaffleFun]()
  for fun_ in yogurt.funs do {
    eprintln("Waffling {fun_.key}")
    funs.&.put(
      WaffleSignature { string = fun_.key.str },
      fun_.value.to_waffle(yogurt),
    )
  }
  Waffle { funs }
}
