| The Universe and Byte Code  
| All Plum objects (including source code) are owned by a universe. First, you
| create an empty universe using the big_bang function. Only then can you
| compile code into that universe. You can then call the compiled functions.

import plum.mar

struct Universe { objects: List[Object] }

struct ObjectId { int: Int } | index in the objects list
enum Object {
  int: Int,
  string: String,
  struct_: Map[String, ObjectId],
  tag: TagObject,
  code: CodeObject, | code from one compilation unit
}
struct TagObject { symbol: String, args: Slice[ObjectId] }
struct CodeObject { funs: List[FunCode] }
struct FunId { int: Int } | index in a code's functions list
struct FunCode { name: String, instructions: Slice[ByteCodeInstruction] }
enum ByteCodeInstruction {
  push_object: ObjectId,
  push_from_stack: Int, | offset from the top of the stack (0 = top, etc.)
  pop_n_below_top: Int, | pops n objects, skipping the top object
  jump: Int, | jumps to the given instruction index inside this function
  jump_table: Map[String, Int], | peeks at the top value (a tag). depending on the symbol, jumps to different instruction indices
  struct_: List[String], | pops the same number of values, pushes a struct
  member: String, | pops a struct, pushes its member with the given name
  tag: Tuple2[String, Int], | symbol and number of arguments
  untag, | consumes a tag, pushes all its args on the stack
  call: FunId, | calls another function from the same compilation unit
  add_ints,
  sub_ints,
  mul_ints,
  div_ints,
  mod_ints,
  and_ints,
  or_ints,
  xor_ints,
  compare_ints,
  concat_strings,
  crash,
}

fun big_bang(): Universe { Universe { objects = list[Object]() } }

fun new(universe: &Universe, object: Object): ObjectId {
  var id = universe.objects.len
  universe.objects.&.push(object)
  ObjectId { int = id }
}
fun get(universe: Universe, id: ObjectId): Object {
  universe.objects.get(id.int)
}
fun get(code: CodeObject, id: FunId): FunCode { code.funs.get(id.int) }

fun write[W](writer: W, universe: Universe) {
  writer."Universe:"
  for object in universe.objects.iter().enumerate() do {
    writer."\n{ObjectId { int = object.index }}: "
    writer.write(object.item)
  }
}
fun write[W](writer: W, id: ObjectId) { writer."#{id.int}" }
fun write[W](writer: W, object: Object) {
  switch object
  case int(int) writer."{int}"
  case string(string) writer."{string.debug()}"
  case struct_(struct_) {
    writer."(&"
    for field in struct_ do writer." {field.key}: {field.value}"
    writer.")"
  }
  case tag(tag) {
    writer."({tag.symbol}"
    for arg in tag.args do writer." {arg}"
    writer.")"
  }
  case code(code) writer."{code}"
}
fun write_deep[W](writer: W, id: ObjectId, universe: Universe) {
  switch universe.get(id)
  case int(int) writer."{int}"
  case string(string) writer."{string.debug()}"
  case struct_(struct_) {
    writer."(&"
    for field in struct_ do {
      writer." {field.key}: "
      writer.write_deep(field.value, universe)
    }
    writer.")"
  }
  case tag(tag) {
    writer."({tag.symbol}"
    for arg in tag.args do {
      writer." "
      writer.write_deep(arg, universe)
    }
    writer.")"
  }
  case code(code) writer."{code}"
}
fun write[W](writer: W, code: CodeObject) {
  for fun_ in code.funs.iter().enumerate() do {
    writer."\n  {FunId { int = fun_.index }} ({fun_.item.name}):"
    for instruction in fun_.item.instructions.iter().enumerate() do {
      writer."\n    {"{instruction.index}".pad_left(3)} | {instruction.item}"
    }
  }
}
fun write[W](writer: W, id: FunId) { writer."fun-{id.int}" }
fun write[W](writer: W, instruction: ByteCodeInstruction) {
  switch instruction
  case push_object(id) writer."push {id}"
  case push_from_stack(n) writer."push top - {n}"
  case pop_n_below_top(n) writer."pop {n} below top"
  case jump(index) writer."jump to {index}"
  case jump_table(table) {
    writer."jump to:"
    for entry in table do writer."\n        |   {entry.key} -> {entry.value}"
  }
  case struct_(field_names) {
    writer."struct with fields"
    for name in field_names do writer." {name}"
  }
  case member(name) writer."get member {name}"
  case tag(tag) writer."tag {tag.a} with {tag.b} args"
  case untag writer."untag"
  case call(function) writer."call {function}"
  case add_ints writer."add_ints"
  case sub_ints writer."sub_ints"
  case mul_ints writer."mul_ints"
  case div_ints writer."div_ints"
  case mod_ints writer."mod_ints"
  case and_ints writer."and_ints"
  case or_ints writer."or_ints"
  case xor_ints writer."xor_ints"
  case compare_ints writer."compare_ints"
  case concat_strings writer."concat_strings"
  case crash writer."crash"
}

struct MainFun { code: ObjectId, id: FunId }

fun compile(yogurt: Yogurt, universe: &Universe): MainFun {
  var signature_to_id = map[YogurtSignature, FunId]()
  for fun_ in yogurt.funs.iter().enumerate() do
    signature_to_id.&.put(fun_.item.key, FunId { int = fun_.index }) | placeholders

  var funs = uninitialized_list[FunCode](yogurt.funs.size)
  for fun_ in yogurt.funs do {
    var signature = fun_.key
    var fun_ = fun_.value
    var id = signature_to_id.get(signature)
    funs.&.get_ref(id.int).* = fun_.compile(signature, universe, signature_to_id)
  }

  var code = universe.new(Object.code(CodeObject { funs }))

  MainFun {
    code,
    id = signature_to_id.get(yogurt_signature(
      "main",
      list(YogurtParam.runtime(PlumType.primitive("Int"))).to_slice()
    ))
  }
}
fun compile(
  fun_: YogurtFun, signature: YogurtSignature,
  universe: &Universe, signature_to_id: Map[YogurtSignature, FunId]
): FunCode {
  var stack_model = list[YogurtId]()
  for param in fun_.body.params do stack_model.&.push(param)
  var instructions = list[ByteCodeInstruction]()

  fun_.body.compile(
    instructions.&, stack_model.&, fun_, universe, signature_to_id
  )

  FunCode { name = signature.str, instructions = instructions.to_slice() }
}
fun compile(
  body: YogurtBody,
  instructions: &List[ByteCodeInstruction],
  stack_model: &List[YogurtId],
  fun_: YogurtFun,
  universe: &Universe,
  signature_to_id: Map[YogurtSignature, FunId],
) {
  for id in body.exprs do {
    var expr = fun_.get(id)
    switch expr.op
    case param panic("param should not exist in body")
    case uninitialized {}
    case comptime(value)
      instructions.push(ByteCodeInstruction.push_object(value.to_object(universe)))
    case struct_(struct_) {
      var fields = list[String]()
      for field in struct_ do fields.&.push(field.key)
      for field in fields do {
        var value = struct_.get(field)
        instructions.push(ByteCodeInstruction.push_from_stack(
          stack_model.find_distance_from_top(value)
        ))
        stack_model.push(value)
      }
      instructions.push(ByteCodeInstruction.struct_(fields))
      stack_model.pop(fields.len)
    }
    case member(member) {
      instructions.push(ByteCodeInstruction.push_from_stack(
        stack_model.find_distance_from_top(member.of)
      ))
      instructions.push(ByteCodeInstruction.member(member.name))
    }
    case tag(tag) {
      for arg in tag.args do {
        instructions.push(ByteCodeInstruction.push_from_stack(
          stack_model.find_distance_from_top(arg)
        ))
        stack_model.push(arg)
      }
      instructions.push(ByteCodeInstruction.tag(tuple(tag.symbol, tag.args.len)))
      stack_model.pop(tag.args.len)
    }
    case switch_(switch_) {
      instructions.push(ByteCodeInstruction.push_from_stack(
        stack_model.find_distance_from_top(switch_.condition)
      ))
      var variants = fun_.get(switch_.condition).type.enum_.unwrap()

      var jump_table_index = instructions.len
      instructions.push(ByteCodeInstruction.jump_table(map[String, Int]()))  | placeholder

      var table = map[String, Int]()
      var end_jumps = list[Int]()
      for case_ in switch_.cases do {
        table.&.put(case_.key, instructions.len)

        var stack_len_before = stack_model.len
        instructions.push(ByteCodeInstruction.untag)
        for param in case_.value.params do stack_model.push(param)
        case_.value.compile(instructions, stack_model, fun_, universe, signature_to_id)
        stack_model.pop().ignore()
        var stack_len_after = stack_model.len
        stack_len_before == stack_len_after or panic("stack len mismatch ({stack_len_before} and {stack_len_after})")

        end_jumps.&.push(instructions.len)
        instructions.push(ByteCodeInstruction.jump(0))  | placeholder
      }
      var end = instructions.len
      for jump in end_jumps do
        instructions.get_ref(jump).* = ByteCodeInstruction.jump(end)
      instructions.get_ref(jump_table_index).* = ByteCodeInstruction.jump_table(table)
    }
    case call(call) {
      for arg in call.args do {
        instructions.push(ByteCodeInstruction.push_from_stack(
          stack_model.find_distance_from_top(arg)
        ))
        stack_model.push(arg)
      }
      var fun_ = signature_to_id.get(call.receiver)
      instructions.push(ByteCodeInstruction.call(fun_))
      stack_model.pop(call.args.len)
    }
    case instruction(instruction) {
      for arg in instruction.args do {
        instructions.push(ByteCodeInstruction.push_from_stack(
          stack_model.find_distance_from_top(arg)
        ))
        stack_model.push(arg)
      }

      switch instruction.instruction
      case add_ints instructions.push(ByteCodeInstruction.add_ints)
      case sub_ints instructions.push(ByteCodeInstruction.sub_ints)
      case mul_ints instructions.push(ByteCodeInstruction.mul_ints)
      case div_ints instructions.push(ByteCodeInstruction.div_ints)
      case mod_ints instructions.push(ByteCodeInstruction.mod_ints)
      case and_ints instructions.push(ByteCodeInstruction.and_ints)
      case or_ints instructions.push(ByteCodeInstruction.or_ints)
      case xor_ints instructions.push(ByteCodeInstruction.xor_ints)
      case compare_ints instructions.push(ByteCodeInstruction.compare_ints)
      case concat_strings instructions.push(ByteCodeInstruction.concat_strings)
      case crash instructions.push(ByteCodeInstruction.crash)

      stack_model.pop(instruction.args.len)
    }
    stack_model.&.push(id)
  }
  instructions.push(ByteCodeInstruction.push_from_stack(
    stack_model.find_distance_from_top(body.returns)
  ))
  instructions.push(ByteCodeInstruction.pop_n_below_top(
    body.params.len + body.exprs.len
  ))
  stack_model.pop(body.params.len + body.exprs.len)
  stack_model.push(body.returns)
}
fun find_distance_from_top(stack_model: List[YogurtId], id: YogurtId): Int {
  for entry in stack_model.to_slice().rev_iter().enumerate() do
    if entry.item == id then return entry.index
  panic("{id} not on stack {stack_model}")
}
fun to_object(value: YogurtValue, universe: &Universe): ObjectId {
  switch value.kind
  case int(int) universe.new(Object.int(int))
  case string(string) universe.new(Object.string(string))
  case type(type) universe.new(Object.string("{type}"))
  case tag(tag) {
    var args = list[ObjectId]()
    for arg in tag.b do args.&.push(arg.to_object(universe))
    universe.new(Object.tag(TagObject { symbol = tag.a, args = args.to_slice() }))
  }
}
