| Converting Yogurt to Byte Code  
|
| Yogurt is converted to byte code for a low-level virtual machine (not LLVM).
| The byte code and VM can be found in vm.mar. This file contains the code that
| compiles Yogurt to byte code.
|
| A big question is how to represent values. Currently, we use the
| memory_layout.mar file to calculate reasonably efficient memory layouts for
| all types. If possible, we save values unboxed and on the stack.
|
| When you call a function, the function expects the arguments to be on the
| stack. Here's an example function:
|
| foo a: Byte b: Int c: Byte -> Int =
|   a + 5
|
| Its Yogurt looks like this:
|
| foo Byte Int Byte: @0 @1 @2
|   @3: Int = comptime 5
|   @4: Int = call "+ Int Int" @1 @3
|   @4
|
| The calling convention is this:
| - When a function runs, the stack has to be aligned to 8 bytes.
| - All arguments to the function should be on the stack as if they were layed
|   out in a struct.
| - After a function returns, the arguments should have been consumed from the
|   stack and replaced by the return value.
|
| For a call "foo 1 2 3", this would be the stack:
|
| @1--------------------- @0 @2 padding----------
| 02 00 00 00 00 00 00 00 01 03 00 00 00 00 00 00
|
| Each local expression (in our case, @3 and @4) are expected to be on the stack
| after they are executed. For example, after the "comptime 5":
|
| @1--------------------- @0 @2 padding---------- @3---------------------
| 02 00 00 00 00 00 00 00 01 03 00 00 00 00 00 00 05 00 00 00 00 00 00 00
|
| The call to + first pushes all arguments to the stack:
|
| 02 00 00 00 00 00 00 00 01 03 00 00 00 00 00 00 05 00 00 00 00 00 00 00
| 02 00 00 00 00 00 00 00 05 00 00 00 00 00 00 00
|
| Then, it calls +. After + completes, the stack will look like this:
|
| 02 00 00 00 00 00 00 00 01 03 00 00 00 00 00 00 05 00 00 00 00 00 00 00
| 07 00 00 00 00 00 00 00
|
| Then, foo cleans up the arguments so that the stack is this:
|
| 07 00 00 00 00 00 00 00

import plum.mar

var padding_byte = 16#aa.lower_byte()

fun compile(yogurt: Yogurt): Address {
  var instructions = list[ByteCodeInstruction]()
  instructions.&.reserve_uninitialized(200) | TODO

  var signature_to_address = map[YogurtSignature, Address]()
  var patches = list[Tuple2[&ByteCodeInstruction, YogurtSignature]]()

  for fun_ in yogurt.funs do {
    var signature = fun_.key
    var fun_ = fun_.value
    signature_to_address.&.put(
      signature, instructions.data.get_ref(instructions.len).to_address()
    )
    fun_.compile(signature, yogurt, instructions.&, patches.&)
  }

  for patch in patches do
    patch.a.* = ByteCodeInstruction.call(signature_to_address.get(patch.b))

  signature_to_address.get(yogurt_signature(
    "main",
    list(YogurtParam.runtime(PlumType.primitive("Int"))).to_slice()
  ))
}
fun compile(
  fun_: YogurtFun, signature: YogurtSignature, yogurt: Yogurt,
  instructions: &List[ByteCodeInstruction],
  patches: &List[Tuple2[&ByteCodeInstruction, YogurtSignature]],
) {
  var builder = ByteCodeBuilder {
    instructions, stack_mapping = map[YogurtId, Int](), stack_size = 0
  }

  { | Lay out parameters on the stack.
    var param_layouts = list[MemoryLayout]()
    for param in fun_.body.params do
      param_layouts.&.push(fun_.get(param).type.memory_layout())
    var layout = param_layouts.to_slice().layout_efficiently()
    for param in fun_.body.params.iter().enumerate() do
      builder.&.add_mapping(param.item, layout.input_to_offset.get(param.index))
    builder.stack_size = layout.size
    eprintln("param mapping: {builder.stack_mapping}")
  }

  if fun_.captured is some(captured) then {
    todo("handle closures")
    | for capture in captured do builder.&.push(capture)
  }

  fun_.body.compile(builder.&, fun_, yogurt, patches)

  | TODO: think about this
  | if fun_.captured is some(captured) then
  |   instructions.&.push(ByteCodeInstruction.pop_n_below_top(captured.len))
}

| Byte Code Builder  
| In order to make it easy to generate byte code and for this to not get out of
| sync with our comptime model of the stack, we have a ByteCodeBuilder. Each
| instruction has a corresponding function that appends the instruction to the
| instruction buffer and also updates the stack model.

struct ByteCodeBuilder {
  instructions: &List[ByteCodeInstruction],
  stack_mapping: Map[YogurtId, Int],
  stack_size: Int,
}
fun add_mapping(builder: &ByteCodeBuilder, id: YogurtId, offset: Int) {
  builder.stack_mapping.&.put(id, offset)
}
fun find_distance_from_top(builder: ByteCodeBuilder, id: YogurtId): Int {
  builder.stack_size - builder.stack_mapping.get(id)
}

fun emit(builder: &ByteCodeBuilder, instruction: ByteCodeInstruction) {
  eprintln("Emitting {instruction}")
  builder.instructions.push(instruction)
  builder.stack_size = builder.stack_size + instruction.stack_size_diff()
}
fun stack_size_diff(instruction: ByteCodeInstruction): Int {
  switch instruction
  case push_8 1
  case push_64 8
  case push_8_from_stack 1
  case push_64_from_stack 8
  case pop_below_top(tuple) 0 - tuple.b
  case jump todo("stack size of jump")
  case jump_table todo("stack size of jump table")
  case lambda_call todo("stack size of lambda call")
  case call 0 | Note: You need to udpate this manually
  case ret 0
  case add_64 -8
  case sub_64 -8
  case mul_64 -8
  case div_64 -8
  case mod_64 -8
  case and_64 -8
  case or_64 -8
  case xor_64 -8
  case malloc -1
  case store_8 -9
  case store_64 -16
  case load_8 -7
  case load_64 0
  case crash todo("stack size of crash")
}

fun push_padding(builder: &ByteCodeBuilder, amount: Int) {
  for i in 0..amount do builder.emit(ByteCodeInstruction.push_8(padding_byte))
}
fun align_to(builder: &ByteCodeBuilder, alignment: Int) {
  builder.push_padding(
    builder.stack_size.round_up_to_multiple_of(alignment) - builder.stack_size
  )
}
fun copy_from_stack(builder: &ByteCodeBuilder, offset: Int, size: Int) {
  if size > offset then
    panic("called copy_from_stack with offset {offset}, but size {size}")
  loop if size < 8 then break else {
    builder.emit(ByteCodeInstruction.push_64_from_stack(offset - 8))
    size = size - 8
  }
  for byte in 0..size do
    builder.emit(ByteCodeInstruction.push_8_from_stack(offset - 1))
}
fun copy_from_stack(builder: &ByteCodeBuilder, id: YogurtId, size: Int) {
  builder.copy_from_stack(builder.find_distance_from_top(id), size)
}
fun push_value(builder: &ByteCodeBuilder, value: YogurtValue) {
  switch value.kind
  case int(int) {
    | 5
    |
    | becomes:
    |
    | push_64 5  | 05 00 00 00 00 00 00 00
    builder.emit(ByteCodeInstruction.push_64(int))
  }
  case string(string) {
    | "hi"
    |
    | becomes:
    |
    | push_64 ...  | 12 34 56 78 00 00 00 00
    | push_64 2    | 12 34 56 78 00 00 00 00 02 00 00 00 00 00 00 00
    builder.emit(ByteCodeInstruction.push_64(string.data.to_int()))
    builder.emit(ByteCodeInstruction.push_64(string.len))
  }
  case struct_(struct_) {
    | & x: 2
    |   y: 3
    |
    | becomes:
    |
    | push_64 2  | 02 00 00 00 00 00 00 00
    | push_64 3  | 02 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00
    var layout = value.type.memory_layout()
    var struct_layout = layout.kind.struct_.unwrap()
    var offset = 0
    for field in struct_layout.fields_sorted_by_offset do {
      var value = struct_.get(field)
      var required_offset = struct_layout.field_to_offset.get(field)
      var size = struct_layout.field_to_layout.get(field).size
      builder.push_padding(required_offset - offset)
      builder.push_value(value)
      offset = required_offset + size
    }
  }
  case tag(tag) {
    | Some 5
    |
    | becomes:
    |
    | push_64 5  | 05 00 00 00 00 00 00 00
    | push_8 0
    var variant = tag.a
    var args = tag.b
    var layout = value.type.memory_layout()
    var enum_layout = layout.kind.enum_.unwrap()
    var args_layout = enum_layout.variants.get(variant)
    var offset = 0
    for index in args_layout.args_sorted_by_offset do {
      var value = args.get(index)
      var required_offset = args_layout.arg_offsets.get(index)
      var size = args_layout.arg_layouts.get(index).size
      builder.push_padding(required_offset - offset)
      builder.push_value(value)
      offset = required_offset + size
    }
    if enum_layout.tag_layout is some(tag) then {
      builder.push_padding(tag.offset_in_enum - offset)
      builder.emit(ByteCodeInstruction.push_8(tag.variant_to_num.get(variant)))
    }
  }
  case lambda(lambda) {
    todo()
    | var captured = list[ObjectId]()
    | for capture in lambda.captures do
    |   captured.&.push(capture.to_instructions(universe, code, signature_to_address))
    | universe.new(Object.lambda(LambdaObject {
    |   code, fun_ = signature_to_address.get(lambda.function),
    |   captured = captured.to_slice()
    | }))
  }
  case type(type) {
    todo()
    | universe.new(Object.string("{type}"))
  }
}

fun compile(
  body: YogurtBody,
  builder: &ByteCodeBuilder,
  fun_: YogurtFun,
  yogurt: Yogurt,
  patches: &List[Tuple2[&ByteCodeInstruction, YogurtSignature]],
) {
  var stack_size_at_body_start = builder.stack_size

  for id in body.exprs do {
    var expr = fun_.get(id)
    var type = expr.type
    var layout = type.memory_layout()
    builder.align_to(layout.alignment)
    builder.add_mapping(id, builder.stack_size)

    switch expr.op
    case param panic("param should not exist in body")
    case uninitialized builder.push_padding(layout.size)
    case comptime(value) builder.push_value(value)
    case struct_(struct_) {
      var layout = expr.type.memory_layout()
      var struct_layout = layout.kind.struct_.unwrap()
      var offset = 0
      for field in struct_layout.fields_sorted_by_offset do {
        var value = struct_.get(field)
        var required_offset = struct_layout.field_to_offset.get(field)
        var size = struct_layout.field_to_layout.get(field).size
        builder.push_padding(required_offset - offset)
        builder.copy_from_stack(value, size)
        offset = required_offset + size
      }
    }
    case member(member) {
      var struct_layout =
        fun_.get(member.of).type.memory_layout().kind.struct_.unwrap()
      var struct_offset = builder.find_distance_from_top(member.of)
      var field_offset_in_struct = struct_layout.field_to_offset.get(member.name)
      var field_offset_from_top = struct_offset - field_offset_in_struct
      var size = struct_layout.field_to_layout.get(member.name).size
      builder.copy_from_stack(field_offset_from_top, size)
    }
    case tag(tag) {
      var enum_layout = type.memory_layout().kind.enum_.unwrap()
      var args_layout = enum_layout.variants.get(tag.symbol)
      var offset = 0
      for index in args_layout.args_sorted_by_offset do {
        var arg = tag.args.get(index)
        var required_offset = args_layout.arg_offsets.get(index)
        var size = args_layout.arg_layouts.get(index).size
        builder.push_padding(required_offset - offset)
        builder.copy_from_stack(id, args_layout.arg_layouts.get(index).size)
        offset = required_offset + size
      }
      if enum_layout.tag_layout is some(layout) then {
        builder.push_padding(layout.offset_in_enum - offset)
        builder.emit(ByteCodeInstruction.push_8(
          layout.variant_to_num.get(tag.symbol)
        ))
      }
    }
    case switch_(switch_) {
      todo("switch")
      | instructions.push(ByteCodeInstruction.push_from_stack(
      |   builder.find_distance_from_top(switch_.condition)
      | ))
      | var variants = fun_.get(switch_.condition).type.enum_.unwrap()

      | var jump_table_index = instructions.len
      | instructions.push(ByteCodeInstruction.jump_table(map[String, Int]()))  | placeholder

      | var table = map[String, Int]()
      | var end_jumps = list[Int]()
      | for case_ in switch_.cases do {
      |   table.&.put(case_.key, instructions.len)

      |   var stack_len_before = builder.len
      |   instructions.push(ByteCodeInstruction.untag)
      |   for param in case_.value.params do builder.push(param)
      |   case_.value.compile(instructions, builder, fun_, code, universe, signature_to_address)
      |   builder.pop().ignore()
      |   var stack_len_after = builder.len
      |   stack_len_before == stack_len_after or panic("stack len mismatch ({stack_len_before} and {stack_len_after})")

      |   end_jumps.&.push(instructions.len)
      |   instructions.push(ByteCodeInstruction.jump(0))  | placeholder
      | }
      | var end = instructions.len
      | for jump in end_jumps do
      |   instructions.get_ref(jump).* = ByteCodeInstruction.jump(end)
      | instructions.get_ref(jump_table_index).* = ByteCodeInstruction.jump_table(table)
    }
    case lambda(lambda) {
      todo("lambda")
      | for capture in lambda.captures do {
      |   instructions.push(ByteCodeInstruction.push_from_stack(
      |     builder.find_distance_from_top(capture)
      |   ))
      |   builder.push(capture)
      | }
      | var fun_ = signature_to_address.get(lambda.function)
      | instructions.push(ByteCodeInstruction.lambda(tuple(fun_, lambda.captures.len)))
      | builder.pop(lambda.captures.len)
    }
    case lambda_call(call) {
      todo("lambda call")
      | for arg in call.args do {
      |   instructions.push(ByteCodeInstruction.push_from_stack(
      |     builder.find_distance_from_top(arg)
      |   ))
      |   builder.push(arg)
      | }
      | instructions.push(ByteCodeInstruction.push_from_stack(
      |   builder.find_distance_from_top(call.lambda)
      | ))
      | builder.push(call.lambda)
      | instructions.push(ByteCodeInstruction.lambda_call(call.args.len))
      | builder.pop(call.args.len + 1)
    }
    case call(call) {
      | Lay out arguments.
      var arg_layouts = list[MemoryLayout]()
      for arg in call.args do
        arg_layouts.&.push(fun_.get(arg).type.memory_layout())
      var layout = arg_layouts.to_slice().layout_efficiently()

      | Copy them from further back on the stack to here.
      for index in layout.inputs_sorted_by_offset do {
        var arg = call.args.get(index)
        var layout = arg_layouts.get(index)
        builder.copy_from_stack(arg, layout.size)
      }
      builder.&.align_to(8)

      builder.emit(ByteCodeInstruction.call(null))
      patches.push(tuple(
        builder.instructions.get_ref(builder.instructions.len - 1),
        call.function
      ))
      builder.stack_size =
        builder.stack_size
        - layout.size
        + yogurt.funs.get(call.function).return_type().memory_layout().size
    }
    case instruction(instruction) {
      for arg in instruction.args do
        builder.copy_from_stack(arg, fun_.get(arg).type.memory_layout().size)

      switch instruction.instruction
      case add_ints builder.emit(ByteCodeInstruction.add_64)
      case sub_ints builder.emit(ByteCodeInstruction.sub_64)
      case mul_ints builder.emit(ByteCodeInstruction.mul_64)
      case div_ints builder.emit(ByteCodeInstruction.div_64)
      case mod_ints builder.emit(ByteCodeInstruction.mod_64)
      case compare_ints todo("compare_ints")
      case and_ints builder.emit(ByteCodeInstruction.and_64)
      case or_ints builder.emit(ByteCodeInstruction.or_64)
      case xor_ints builder.emit(ByteCodeInstruction.xor_64)
      case concat_strings todo("concat_strings")
      case crash {
        todo("crash args")
        builder.emit(ByteCodeInstruction.crash)
      }
    }
  }

  | Function postamble.

  var size_of_params = {
    var param_layouts = list[MemoryLayout]()
    for param in body.params do
      param_layouts.&.push(fun_.get(param).type.memory_layout())
    param_layouts.to_slice().layout_efficiently().size
  }
  var size_of_locals = builder.stack_size - stack_size_at_body_start
  var return_value_size = fun_.get(body.returns).type.memory_layout().size

  eprintln("mapping: {builder.stack_mapping} size: {builder.stack_size}")
  builder.copy_from_stack(body.returns, return_value_size)
  builder.emit(ByteCodeInstruction.pop_below_top(tuple(
    return_value_size, size_of_params + size_of_locals
  )))
  builder.emit(ByteCodeInstruction.ret)
}
