| Convert Egg to Yogurt  

import plum.mar

fun to_yogurt(egg: Egg): Result[Yogurt, Error] {
  var main = egg.lookup("main", list(type_int).to_slice()) or
    return error[Yogurt, Error](error("No main function.", invalid_src()))
  var yogurt = yogurt()
  main.compile(yogurt_compiler(egg, yogurt.&).&)?
  ok[Yogurt, Error](yogurt)
}

| Compilers  
|
| When compiling to Yogurt, we execute some functions at comptime and we
| specialize generic functions for concrete types (aka monomorphization). When
| doing that, we need to be careful about recursive functions:
|
| - For comptime execution, recursive calls result in a compiler error.
| - For normal compilation, recursive calls are fine. Still, we need to detect
|   recursive calls so that the compiler itself doesn't get stuck in infinite
|   recursion.

struct YogurtCompiler {
  | The stack is the stack of the compiler itself, containing the signatures of
  | comptime calls and monomorphized functions.
  stack: List[YogurtStackEntry],
  egg: Egg,
  yogurt: &Yogurt,
}
enum YogurtStackEntry { compiling: YogurtSignature, running: YogurtSignature }

fun yogurt_compiler(egg: Egg, yogurt: &Yogurt): YogurtCompiler {
  YogurtCompiler { stack = list[YogurtStackEntry](), egg, yogurt }
}

fun ==(a: YogurtStackEntry, b: YogurtStackEntry): Bool {
  switch a
  case compiling(a) if b is compiling(b) then a == b else false
  case running(a)   if b is running(b)   then a == b else false
}

fun start_running(compiler: &YogurtCompiler, signature: YogurtSignature) {
  compiler.stack.&.push(YogurtStackEntry.running(signature))
  compiler.print_status()
}
fun done_running(compiler: &YogurtCompiler) {
  compiler.stack.&.pop().running or panic("wasn't running something")
  compiler.print_status()
}
fun is_currently_running(
  compiler: YogurtCompiler, signature: YogurtSignature
): Bool {
  compiler.stack.iter().&.contains(YogurtStackEntry.running(signature))
}

fun start_compiling(compiler: &YogurtCompiler, signature: YogurtSignature) {
  compiler.stack.&.push(YogurtStackEntry.compiling(signature))
  compiler.print_status()
}
fun done_compiling(compiler: &YogurtCompiler) {
  compiler.stack.&.pop().compiling or panic("wasn't running something")
  compiler.print_status()
}
fun is_currently_compiling(
  compiler: YogurtCompiler, signature: YogurtSignature
): Bool {
  compiler.stack.iter().&.contains(YogurtStackEntry.compiling(signature))
}

fun define(
  compiler: &YogurtCompiler, signature: YogurtSignature, fun_: YogurtFun
) {
  compiler.yogurt.funs.&.put(signature, fun_)
}
fun is_defined(compiler: YogurtCompiler, signature: YogurtSignature): Bool {
  compiler.yogurt.funs.contains(signature)
}
fun get(compiler: YogurtCompiler, signature: YogurtSignature): YogurtFun {
  compiler.yogurt.funs.get(signature)
}

fun write_ansi_escape_sequence[W](writer: W, sequence: String) {
  writer.write(27.lower_byte().to_char())
  writer.write(sequence)
}
fun move_cursor_to_front[W](writer: W) { writer.write_ansi_escape_sequence("[G") }
fun erase_rest_of_current_line[W](writer: W) { writer.write_ansi_escape_sequence("[K") }
fun move_cursor_to_next[W](writer: W, n: Int) {
  if n > 0 then writer.write_ansi_escape_sequence("[{n}E")
}
fun move_cursor_to_previous[W](writer: W, n: Int) {
  if n > 0 then writer.write_ansi_escape_sequence("[{n}F")
}
var max_preprinted_lines = 0

fun print_status(compiler: &YogurtCompiler) {
  for i in 0..max_preprinted_lines do {
    stderr.move_cursor_to_front()
    stderr.erase_rest_of_current_line()
    stderr.move_cursor_to_next(1)
  }
  stderr.move_cursor_to_previous(max_preprinted_lines)

  var num_printed = 0
  for entry in compiler.stack do {
    if num_printed == 5 then break {}

    var comptime_and_signature =
      switch entry
      case compiling(signature) tuple(false, signature)
      case running(signature) tuple(true, signature)
    var comptime = comptime_and_signature.a
    var signature = comptime_and_signature.b

    if comptime then stderr.write_ansi_escape_sequence("[32m")
    if signature.str.len > 60 then
      stderr."{signature.str.substr(0..57)}..."
    else
      stderr."{signature}"
    if comptime then stderr.write_ansi_escape_sequence("[0m")
    stderr."\n"

    num_printed = num_printed + 1
  }
  stderr.move_cursor_to_previous(num_printed)
  max_preprinted_lines = num_printed
}

struct YogurtCodeCompiler {
  parent: &YogurtCompiler,
  code: EggCode,
  egg_to_yogurt: Map[EggId, YogurtId],
}

fun code_compiler(compiler: &YogurtCompiler, code: EggCode): YogurtCodeCompiler {
  YogurtCodeCompiler {
    parent = compiler, code, egg_to_yogurt = map[EggId, YogurtId]()
  }
}
fun add_mapping(
  compiler: &YogurtCodeCompiler, egg_id: EggId, yogurt_id: YogurtId
) {
  compiler.egg_to_yogurt.&.put(egg_id, yogurt_id)
}
fun lookup(compiler: YogurtCodeCompiler, egg_id: EggId): YogurtId {
  compiler.egg_to_yogurt.get(egg_id)
}

struct YogurtFunBuilder { exprs: List[YogurtExpr] }

fun yogurt_fun_builder(): _ { YogurtFunBuilder { exprs = list[YogurtExpr]() } }
fun push(builder: &YogurtFunBuilder, expr: YogurtExpr): YogurtId {
  var id = YogurtId { int = builder.exprs.len }
  builder.exprs.&.push(expr)
  id
}
fun get(builder: YogurtFunBuilder, id: YogurtId): YogurtExpr {
  builder.exprs.get(id.int)
}

| Looking up functions in the Egg  
| Whenever a function is called, we need to choose the correct function based on
| the name and argument types.

struct MatchingFun { fun_: EggFun, substitutions: Substitutions }

fun name(match: MatchingFun): String { match.fun_.name.string }
fun param_types(match: MatchingFun): Slice[PlumType] {
  var types = list[PlumType]()
  for param in match.fun_.params do
    types.&.push(param.type.specialize(match.substitutions))
  types.to_slice()
}
fun return_type(match: MatchingFun): PlumType {
  match.fun_.return_type.specialize(match.substitutions)
}

fun lookup(
  egg: Egg, name: String, args: Slice[PlumType],
): Result[MatchingFun, String] {
  var name_matches = list[EggFun]()
  for fun_ in egg.funs do
    if fun_.name.string == name then
      name_matches.&.push(fun_)
  if name_matches.is_empty() then
    return error[MatchingFun, String]("There is no function named {name.debug()}.")

  var full_matches = list[Tuple2[EggFun, Substitutions]]()
  for fun_ in name_matches do {
    fun_.params.len == args.len or continue
    var constraints = constraints()
    var param_types = list[PlumType]()
    for param in fun_.params do param_types.&.push(param.type)
    var substitutions =
      args.match_against(param_types.to_slice(), constraints) or continue

    full_matches.&.push(tuple(fun_, substitutions))
  }

  if full_matches.is_empty() then
    return error[MatchingFun, String](
      "There is no matching function named {name} for the args {args}.")
  if full_matches.len > 1 then
    return error[MatchingFun, String]({
      var b = string_builder().&
      b."multiple functions match {name} {args}:"
      for match in full_matches do
        b."\n  {match.a.name.string} {match.a.params}  (with {match.b.debug()})"
      b.to_string()
    })
  var fun_and_substitutions = full_matches.get(0)

  ok[MatchingFun, String](MatchingFun {
    fun_          = fun_and_substitutions.a,
    substitutions = fun_and_substitutions.b,
  })
}

| Running code at compile time  
| Plum guarantees that functions with compile-time known args run at compile
| time. Here is the code for that.

enum ComptimeResult {
  returns: YogurtValue,
  runtime_crash: Tuple2[String, PlumType],
  comptime_error: String,
}

fun run(
  match: MatchingFun, args: Slice[YogurtValue], compiler: &YogurtCompiler
): ComptimeResult {
  var signature = yogurt_signature(match.name(), args)

  if compiler.is_currently_running(signature) then
    panic("infinite comptime recursion") | TODO: report the error
  compiler.start_running(signature)

  var result =
    switch match.fun_.impl
    case code(code) {
      var builder = yogurt_fun_builder()
      var compiler = compiler.code_compiler(code)

      var params = list[YogurtId]()
      for both in zip(code.body.params.iter(), args.iter()) do {
        var egg_id = both.a
        var yogurt_id = builder.&.push(both.b.to_expr())
        params.&.push(yogurt_id)
        compiler.&.add_mapping(egg_id, yogurt_id)
      }
      var params = params.to_slice()

      var body =
        code.body.compile(params, builder.&, compiler.&)
          or(error) return ComptimeResult.comptime_error(error.message)

      var value =
        | TODO: handle panics?
        switch builder.get(body.returns).op
        case comptime(value) value
        default
          panic("Comptime call results in runtime result: 
            '{builder.get(body.returns).op.debug()}")

      | Check that the return type matches what the function claims it is.
      var claimed_return_type = match.return_type()
      value.type.is_assignable_to(claimed_return_type) or
        return ComptimeResult.comptime_error(
          "Return types don't match:\n
          'claimed type: {claimed_return_type}\n
          ' actual type: {value.type}"
        )
      var value = value.comptime_cast(claimed_return_type)

      ComptimeResult.returns(value)
    }
    case builtin(builtin) builtin.run(args)

  compiler.done_running()
  result
}
fun run(builtin: Builtin, args: Slice[YogurtValue]): ComptimeResult {
  var value =
    switch builtin
    case add_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      yogurt_value_int(a + b)
    }
    case sub_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      yogurt_value_int(a - b)
    }
    case mul_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      yogurt_value_int(a * b)
    }
    case div_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      if b == 0 then
        return ComptimeResult.runtime_crash(tuple("Divide by zero.", type_int))
      yogurt_value_int(a / b)
    }
    case mod_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      if b == 0 then
        return ComptimeResult.runtime_crash(tuple("Mod by zero.", type_int))
      yogurt_value_int(a % b)
    }
    case and_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      yogurt_value_int(a & b)
    }
    case or_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      yogurt_value_int(or(a, b))
    }
    case xor_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      yogurt_value_int(a ^ b)
    }
    case compare_ints {
      var a = args.get(0).kind.int.unwrap()
      var b = args.get(1).kind.int.unwrap()
      var symbol =
        switch a <=> b
        case less "Less"
        case equal "Equal"
        case greater "Greater"
      yogurt_value_symbol(symbol).comptime_cast(type_ordering)
    }
    case concat_strings {
      var a = args.get(0).kind.string.unwrap()
      var b = args.get(1).kind.string.unwrap()
      yogurt_value_string("{a}{b}")
    }
    case crash {
      var message = args.get(0).kind.string.unwrap()
      return ComptimeResult.runtime_crash(tuple(message, type_never))
    }
    case type_of {
      var value = args.get(0)
      yogurt_value_type(value.type)
    }
    case type_info {
      var type = args.get(0).kind.type.unwrap()
      {
        switch type.extend_one_level()
        case primitive(name) yogurt_value_symbol(name)
        case never yogurt_value_symbol("Never")
        case struct_(struct_)
          yogurt_value_variant("Struct", list(yogurt_value_list({
            var fields = list[YogurtValue]()
            for field in struct_ do {
              fields.&.push(yogurt_value_struct(map(
                "name" -> yogurt_value_string(field.key),
                "type" -> yogurt_value_type(field.value),
              )))
            }
            fields.to_slice()
          }, type_field)).to_slice())
        case enum_(enum_)
          yogurt_value_variant("Enum", list(yogurt_value_list({
            var variants = list[YogurtValue]()
            for variant in enum_ do {
              variants.&.push(yogurt_value_struct(map(
                "name" -> yogurt_value_string(variant.key),
                "args" -> yogurt_value_list({
                  var args = list[YogurtValue]()
                  for arg in variant.value do
                    args.&.push(yogurt_value_type(arg))
                  args.to_slice()
                }, type_type),
              )))
            }
            variants.to_slice()
          }, type_variant)).to_slice())
        case lambda todo()
        case recursive unreachable()
      }.comptime_cast(type_type_info)
    }
  ComptimeResult.returns(value)
}

fun comptime_cast(value: YogurtValue, target: PlumType): YogurtValue {
  switch value.kind
  case int value
  case string value
  case struct_(struct_) {
    YogurtValueKind.struct_({
      var fields = map[String, YogurtValue]()
      var field_types = target.extend_one_level().struct_.unwrap()
      for field in struct_ do
        fields.&.put(
          field.key,
          field.value.comptime_cast(field_types.get(field.key))
        )
      fields
    }) $ target
  }
  case variant(variant) {
    YogurtValueKind.variant(YogurtVariantValue {
      symbol = variant.symbol,
      payloads = {
        var payloads = list[YogurtValue]()
        var payload_types =
          target.extend_one_level().enum_.unwrap().get(variant.symbol)
        for both in zip(variant.payloads.iter(), payload_types.iter()) do
          payloads.&.push(both.a.comptime_cast(both.b))
        payloads.to_slice()
      }
    }) $ target
  }
  case lambda todo("comptime cast lambdas")
  case type value
}

| Compiling code to run at runtime  
| If not all arguments to a function are known at compile-time, the function is
| compiled into some code that will run later (at runtime).

fun compile(
  match: MatchingFun, compiler: &YogurtCompiler
): Result[YogurtSignature, Error] {
  var param_types = match.param_types()
  var signature = yogurt_signature(match.name(), param_types)

  if compiler.is_defined(signature) or compiler.is_currently_compiling(signature)
  then
    return ok[YogurtSignature, Error](signature)
  compiler.start_compiling(signature)

  var fun_ =
    switch match.fun_.impl
    case code(code) {
      var builder = yogurt_fun_builder()
      var compiler = compiler.code_compiler(code)

      var params = list[YogurtId]()
      for both in zip(code.body.params.iter(), param_types.iter()) do {
        var egg_id = both.a
        var yogurt_id = builder.&.push(YogurtOp.param $ both.b)
        params.&.push(yogurt_id)
        compiler.&.add_mapping(egg_id, yogurt_id)
      }
      var params = params.to_slice()

      var body = code.body.compile(params, builder.&, compiler.&)?

      | Check that the return type matches what the function claims it is.
      var claimed_return_type = match.return_type()
      var actual_return_type = builder.get(body.returns).type
      if claimed_return_type != actual_return_type then {
        actual_return_type.is_assignable_to(claimed_return_type) or
          return error[YogurtSignature, Error](error(
            "Return types don't match:\n
            'claimed type: {claimed_return_type}\n
            ' actual type: {actual_return_type}",
            match.fun_.name.src
          ))

        var body_with_cast = list[YogurtId]()
        for id in body.exprs do body_with_cast.&.push(id)
        var cast_fun =
          compile_cast_fun(actual_return_type, claimed_return_type, compiler.parent)
        var cast = builder.&.push(
          if builder.get(body.returns).op is comptime(value) then
            value.comptime_cast(claimed_return_type).to_expr()
          else {
            YogurtOp.call(YogurtCall {
              function = cast_fun, args = list(body.returns).to_slice()
            }) $ claimed_return_type
          }
        )
        body_with_cast.&.push(cast)
        body = YogurtBody {
          params = body.params,
          exprs = body_with_cast.to_slice(),
          returns = cast,
        }
      }

      YogurtFun {
        captures = none[Slice[YogurtId]](),
        exprs = builder.exprs.to_slice(),
        body,
      }
    }
    case builtin(builtin) builtin.compile(param_types, compiler)?

  compiler.define(signature, fun_)
  compiler.done_compiling()
  ok[YogurtSignature, Error](signature)
}

fun compile(
  body: EggBody, params: Slice[YogurtId],
  builder: &YogurtFunBuilder, compiler: &YogurtCodeCompiler
): Result[YogurtBody, Error] {
  params.len == body.params.len or
    panic("body params len doesn't match the number of param types")
  var exprs = list[YogurtId]()
  for egg_id in body.exprs do {
    var yogurt_id = compiler.code.get(egg_id)
      .compile(builder, compiler, exprs.&)?
    compiler.add_mapping(egg_id, yogurt_id)
  }
  ok[YogurtBody, Error](YogurtBody {
    params, exprs = exprs.to_slice(), returns = compiler.lookup(body.returns)
  })
}
fun compile(
  expr: EggExpr, builder: &YogurtFunBuilder, compiler: &YogurtCodeCompiler,
  body: &List[YogurtId],
): Result[YogurtId, Error] {
  var id =
    switch expr.kind
    case param unreachable()
    case int(int) builder.push(yogurt_value_int(int).to_expr())
    case string(string) builder.push(yogurt_value_string(string).to_expr())
    case symbol(symbol) builder.push(yogurt_value_symbol(symbol).to_expr())
    case struct_(struct_) {
      var fields = map[String, YogurtId]()
      var field_types = map[String, PlumType]()
      for field in struct_ do {
        var field_id = compiler.lookup(field.value)
        var type = builder.get(field_id).type
        fields.&.put(field.key, field_id)
        field_types.&.put(field.key, type)
      }
      var type = PlumType.struct_(field_types)

      var is_comptime = true
      for field in fields do
        if not(builder.get(field.value).op is comptime) then is_comptime = false

      builder.push(
        if is_comptime then
          yogurt_value_struct({
            var field_values = map[String, YogurtValue]()
            for field in fields do
              field_values.&.put(
                field.key, builder.get(field.value).op.comptime.unwrap())
            field_values
          }).comptime_cast(type).to_expr()
        else
          YogurtOp.struct_(fields) $ type
      )
    }
    case member(member) {
      var of = compiler.lookup(member.of)
      var of_type = builder.get(of).type.extend_one_level()
      var of_fields = of_type.struct_
        or return error[YogurtId, Error](error(
          "Looked for member on non-struct: {of_type}", expr.src
        ))
      var type = of_fields.get_maybe(member.name)
        or return error[YogurtId, Error](error(
          "{member.name} doesn't exist: {of_fields}", expr.src
        ))

      builder.push({
        if builder.get(of).op is comptime(value)
        then YogurtOp.comptime(value.kind.struct_.unwrap().get(member.name))
        else YogurtOp.member(YogurtMember { of, name = member.name })
      } $ type)
    }
    case switch_(switch_) {
      var condition = compiler.lookup(switch_.condition)
      var condition_expr = builder.get(condition)
      var condition_type = condition_expr.type.extend_one_level()
      var condition_variants = condition_type.enum_
        or return error[YogurtId, Error](error(
          "Switched on non-enum: {condition_type}", expr.src
        ))

      | Make sure all variants are handled, that no extra variants are handled,
      | and that the number of parameters of each case match the variant args.
      for variant in condition_variants do
        switch_.cases.contains(variant.key) or
          return error[YogurtId, Error](error(
            "you switch on {condition_type}, but you don't handle the {variant.key} variant",
            expr.src
          ))
      for case_ in switch_.cases do
        condition_variants.contains(case_.key) or
          return error[YogurtId, Error](error(
            "you switch on {condition_type} and you try to handle the non-existent {case_.key} variant",
            expr.src
          ))
      for case_ in switch_.cases do {
        var variant_args = condition_variants.get(case_.key)
        var case_params = case_.value.params
        variant_args.len == case_params.len or
          return error[YogurtId, Error](error(
            "{case_.key} has {variant_args.len} args, but your case binds {case_params.len}",
            expr.src
          ))
      }

      if condition_expr.op is comptime(condition_value) then {
        | If the condition is comptime-known, then we only compile the
        | corresponding branch.
        var actual_variant = condition_value.kind.variant.unwrap()
        var case_ = switch_.cases.get(actual_variant.symbol)

        var params = list[YogurtId]()
        for payload in actual_variant.payloads do
          params.&.push(builder.push(payload.to_expr()))
        var params = params.to_slice()
        for both in zip(case_.params.iter(), params.iter()) do
          compiler.&.add_mapping(both.a, both.b)

        var case_body = case_.compile(params, builder, compiler)?

        for id in case_body.params do body.push(id)
        for id in case_body.exprs do body.push(id)
        case_body.returns
      } else {
        | The condition of the switch is only known at runtime. Compile all
        | branches. 
        | TODO: simplify this branch (we know the condition is not comptime)

        | Lower all cases.
        var cases = map[String, YogurtBody]()
        var case_types = list[PlumType]()
        for variant in condition_variants do {
          var case_ = switch_.cases.get(variant.key)

          var params = none[Slice[YogurtId]]()
          if condition_expr.op is comptime(condition_value) then {
            var actual_variant = condition_value.kind.variant.unwrap()
            if actual_variant.symbol == variant.key then {
              var ids = list[YogurtId]()
              for payload in actual_variant.payloads do
                ids.&.push(builder.push(payload.to_expr()))
              params = some(ids.to_slice())
            }
          }
          var params = params or {
            var ids = list[YogurtId]()
            for type in variant.value do
              ids.&.push(builder.push(YogurtOp.param $ type))
            ids.to_slice()
          }
          for both in zip(case_.params.iter(), params.iter()) do
            compiler.&.add_mapping(both.a, both.b)

          var body = case_.compile(params, builder, compiler)?
          cases.&.put(variant.key, body)
          case_types.&.push(builder.get(body.returns).type)
        }

        | Find the common type of all branches.
        var common_type = union(case_types.to_slice())
          or return error[YogurtId, Error](error("Couldn't union types {case_types}", expr.src))

        | Add cast expressions where necessary.
        for case_ in cases do {
          var case_expr = builder.get(case_.value.returns)
          var case_type = case_expr.type
          if case_type != common_type then {
            var old_body = case_.value
            var new_exprs = list[YogurtId]()
            for expr in old_body.exprs do new_exprs.&.push(expr)
            var new_returns = builder.push({
              if case_expr.op is comptime(value)
              then YogurtOp.comptime(value.comptime_cast(common_type))
              else YogurtOp.call(YogurtCall {
                function = compile_cast_fun(case_type, common_type, compiler.parent),
                args = list(old_body.returns).to_slice()
              })
            } $ common_type)
            new_exprs.&.push(new_returns)
            cases.&.put(case_.key, YogurtBody {
              params = old_body.params,
              exprs = new_exprs.to_slice(),
              returns = new_returns,
            })
          }
        }

        if condition_expr.op is comptime(value) then {
          var value = value.kind.variant.unwrap()
          var variant = value.symbol
          var case_body = cases.get(variant)
          for id in case_body.params do body.push(id)
          for id in case_body.exprs do body.push(id)
          case_body.returns
        } else
          builder.push(
            YogurtOp.switch_(YogurtSwitch { condition, cases }) $ common_type
          )
      }
    }
    case lambda(lambda) {
      | Figure out which variables the lambda captures and look these up in the
      | current scope.
      var captured_egg_ids = expr.captured_variables(compiler.code)

      var captures = list[YogurtId]()
      for egg_id in captured_egg_ids do
        captures.&.push(compiler.lookup(egg_id))
      var captures = captures.to_slice()

      | Compile the lambda body into a stand-alone function that takes the
      | closure as an explicit first argument.
      var function = {
        var lambda_builder = yogurt_fun_builder()
        var lambda_compiler = compiler.parent.code_compiler(compiler.code)

        var inner_captures = list[YogurtId]() | captured values from the pov of the lambda
        for ids in zip(captured_egg_ids.iter(), captures.iter()) do {
          var yogurt_id = lambda_builder.&.push(
            YogurtOp.param $ builder.get(ids.b).type
          )
          inner_captures.&.push(yogurt_id)
          lambda_compiler.&.add_mapping(ids.a, yogurt_id)
        }
        var params = list[YogurtId]()
        for i in 0..lambda.params.len do {
          var egg_id = lambda.body.params.get(i)
          var yogurt_id = lambda_builder.&.push(
            YogurtOp.param $ lambda.params.get(i).type
          )
          params.&.push(yogurt_id)
          lambda_compiler.&.add_mapping(egg_id, yogurt_id)
        }
        var exprs = list[YogurtId]()
        for egg_id in lambda.body.exprs do {
          var yogurt_id = lambda_compiler.code.get(egg_id)
            .compile(lambda_builder.&, lambda_compiler.&, exprs.&)?
          lambda_compiler.&.add_mapping(egg_id, yogurt_id)
        }
        var lambda_body = YogurtBody {
          params = params.to_slice(),
          exprs = exprs.to_slice(),
          returns = lambda_compiler.lookup(lambda.body.returns),
        }

        var function = yogurt_signature("lambda-{expr.src}", empty_slice[PlumType]())
        compiler.parent.define(function, YogurtFun {
          exprs = lambda_builder.exprs.to_slice(),
          captures = some(inner_captures.to_slice()),
          body = lambda_body,
        })
        function
      }

      | eprintln(lambda_compiler.egg_to_yogurt)

      | Create a lambda that contains both the closure and a function pointer.
      var type = PlumType.lambda(LambdaType {
        args = {
          var param_types = list[PlumType]()
          for param in lambda.params do param_types.&.push(param.type)
          param_types.to_slice()
        },
        return_type = compiler.parent.get(function).return_type().put_on_heap(),
      })
      var is_comptime = false
      | for capture in captured do
      |   if not(builder.get(capture).op is comptime) then is_comptime = false
      builder.push({
        | if is_comptime
        | then
        |   YogurtOp.comptime(YogurtValueKind.lambda(YogurtLambdaValue {
        |     captures = {
        |       var captures = list[YogurtValue]()
        |       for capture in captured do
        |         captures.&.push(builder.get(capture).op.comptime.unwrap())
        |       captures.to_slice()
        |     },
        |     function,
        |   }) $ type)
        | else
          YogurtOp.lambda(YogurtLambda { captures, function })
      } $ type)
    }
    case lambda_call(call) {
      var lambda = compiler.lookup(call.lambda)

      var args = list[YogurtId]()
      for arg in call.args do args.&.push(compiler.lookup(arg))
      var args = args.to_slice()

      | Make sure arg types match the lambda type.
      var lambda_type = builder.get(lambda).type.lambda or
        return error[YogurtId, Error](error(
          "Called non-lambda ({builder.get(lambda).type})",
          expr.src,
        ))
      for both in zip(args.iter(), lambda_type.args.iter()) do {
        var actual_type   = builder.get(both.a).type
        var expected_type = both.b
        | TODO: relax?
        actual_type == expected_type or
          return error[YogurtId, Error](error(
            "Lambda expects {expected_type}, got {actual_type})",
            expr.src,
          ))
      }
      var return_type = lambda_type.return_type.*

      var are_all_args_comptime = true
      for arg in args do
        if not(builder.get(arg).op is comptime) then
          are_all_args_comptime = false
      var comptime_result = are_all_args_comptime

      if comptime_result and false then {
        | body.push(builder.push(YogurtOp.lambda_call(YogurtCall {
        |   function = yogurt_signature(name.string, arg_params), args
        | }) $ type))
        | if compiled_fun.body.returns.int == -1 then {
        |   return error[YogurtId, Error](error(
        |     "A function with only comptime known arguments calls itself with those same arguments. 
        |     'We can't run this at comptime.",
        |     expr.src,
        |   ))
        | }
        | var returned_expr = compiled_fun.get(compiled_fun.body.returns)
        | var value = returned_expr.op.comptime
        |   .unwrap("value should be comptime known,but it's {returned_expr.op.debug()}")
        | builder.push(YogurtOp.comptime(value) $ type)
        todo()
      } else {
        builder.push(
          YogurtOp.lambda_call(YogurtLambdaCall { lambda, args }) $ return_type
        )
      }
    }
    case call(call) {
      var name = call.function

      var args = list[YogurtId]()
      for arg in call.args do args.&.push(compiler.lookup(arg))
      var args = args.to_slice()

      var arg_types = list[PlumType]()
      for arg in args do arg_types.&.push(builder.get(arg).type)
      var arg_types = arg_types.to_slice()

      var fun_ = compiler.parent.egg.lookup(name.string, arg_types) or(error)
        return error[YogurtId, Error](error(error, name.src))

      var are_all_args_comptime = true
      for arg in args do
        if not(builder.get(arg).op is comptime) then
          are_all_args_comptime = false

      | TODO: run builtin type of also at comptime
      | var comptime_result = are_all_args_comptime or name.string == "builtin_type_of"
      if are_all_args_comptime then {
        var arg_values = list[YogurtValue]()
        for arg in args do arg_values.&.push(builder.get(arg).op.comptime.unwrap())
        var arg_values = arg_values.to_slice()

        var result = fun_.run(arg_values, compiler.parent)
        switch result
        case returns(value) builder.push(value.to_expr())
        case runtime_crash(crash) {
          var message = builder.push(yogurt_value_string(crash.a).to_expr())
          builder.push(YogurtOp.instruction(YogurtInstruction {
            instruction = Instruction.crash,
            args = list(message).to_slice(),
          }) $ crash.b)
        }
        case comptime_error(message)
          return error[YogurtId, Error](error(message, name.src))
      } else {
        builder.push(
          YogurtOp.call(YogurtCall {
            function = fun_.compile(compiler.parent)?, args
          }) $ fun_.return_type()
        )
      }
    }
    case variant(variant) {
      var symbol = variant.symbol

      var payloads = list[YogurtId]()
      var payload_types = list[PlumType]()
      for payload in variant.payloads do {
        var payload = compiler.lookup(payload)
        var type = builder.get(payload).type
        payloads.&.push(payload)
        payload_types.&.push(type)
      }
      var payloads = payloads.to_slice()
      var payload_types = payload_types.to_slice()
      var type = PlumType.enum_(map(symbol -> payload_types))

      var is_comptime = true
      for payload in payloads do
        if not(builder.get(payload).op is comptime) then is_comptime = false

      builder.push({
        if is_comptime
        then YogurtOp.comptime(YogurtValueKind.variant(YogurtVariantValue {
          symbol,
          payloads = {
            var comptime_payloads = list[YogurtValue]()
            for payload in payloads do
              comptime_payloads.&.push(builder.get(payload).op.comptime.unwrap())
            comptime_payloads.to_slice()
          }
        }) $ type)
        else YogurtOp.variant(YogurtVariant { symbol, payloads })
      } $ type)
    }
  body.push(id)
  ok[YogurtId, Error](id)
}


fun captured_variables(expr: EggExpr, code: EggCode): Slice[EggId] {
  var ignore = set[EggId]()
  var captured = list[EggId]()
  expr.collect_captured(ignore.&, captured.&, code)
  captured.to_slice()
}
fun collect_captured(id: EggId, ignore: &Set[EggId], captured: &List[EggId]) {
  if not(ignore.contains(id)) then {
    captured.push(id)
    ignore.put(id)
  }
}
fun collect_captured(
  body: EggBody, ignore: &Set[EggId], captured: &List[EggId], code: EggCode
) {
  for param in body.params do ignore.put(param)
  for id in body.exprs do {
    code.get(id).collect_captured(ignore, captured, code)
    ignore.put(id)
  }
}
fun collect_captured(
  expr: EggExpr, ignore: &Set[EggId], captured: &List[EggId], code: EggCode
) {
  switch expr.kind
  case param unreachable()
  case int {}
  case string {}
  case struct_(struct_)
    for field in struct_ do field.value.collect_captured(ignore, captured)
  case member(member) member.of.collect_captured(ignore, captured)
  case symbol {}
  case variant(variant)
    for payload in variant.payloads do payload.collect_captured(ignore, captured)
  case switch_(switch_) {
    switch_.condition.collect_captured(ignore, captured)
    for case_ in switch_.cases do
      case_.value.collect_captured(ignore, captured, code)
  }
  case lambda(lambda) lambda.body.collect_captured(ignore, captured, code)
  case lambda_call(call) {
    call.lambda.collect_captured(ignore, captured)
    for arg in call.args do arg.collect_captured(ignore, captured)
  }
  case call(call)
    for arg in call.args do arg.collect_captured(ignore, captured)
}


struct YogurtBodyBuilder { parent: &YogurtFunBuilder, body: List[YogurtId] }
fun push(body: &YogurtBodyBuilder, expr: YogurtExpr): YogurtId {
  var id = body.parent.&.push(expr)
  body.body.&.push(id)
  id
}
fun get(body: YogurtBodyBuilder, id: YogurtId): YogurtExpr {
  body.parent.get(id)
}
fun compile(
  builtin: Builtin, param_types: Slice[PlumType], context: &YogurtCompiler,
): Result[YogurtFun, Error] {
  var signature = yogurt_signature("builtin_{builtin}", param_types)

  var fun_builder = yogurt_fun_builder()
  var body = YogurtBodyBuilder {
    parent = fun_builder.&, body = list[YogurtId]()
  }

  var params = list[YogurtId]()
  for type in param_types do
    params.&.push(body.parent.&.push(YogurtOp.param $ type))
  var params = params.to_slice()

  var returns = builtin.compile(body.&, params) or(error)
    return error[YogurtFun, Error](error(error, invalid_src()))
  var fun_ = YogurtFun {
    exprs = fun_builder.exprs.to_slice(),
    captures = none[Slice[YogurtId]](),
    body = YogurtBody { params, exprs = body.body.to_slice(), returns }
  }

  context.yogurt.funs.&.put(signature, fun_)
  ok[YogurtFun, Error](fun_)
}
fun compile(
  builtin: Builtin, builder: &YogurtBodyBuilder, params: Slice[YogurtId]
): Result[YogurtId, String] {
  ok[YogurtId, String](
    switch builtin
    case add_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.add_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case sub_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.sub_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case mul_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.mul_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case div_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.div_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case mod_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.mod_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case and_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.and_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case or_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.or_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case xor_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.xor_ints, args = list(a, b).to_slice()
      }) $ type_int)
    }
    case compare_ints {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(
        YogurtOp.instruction(YogurtInstruction {
          instruction = Instruction.compare_ints, args = list(a, b).to_slice()
        }) $ type_ordering
      )
    }
    case concat_strings {
      var a = params.get(0)
      var b = params.get(1)
      builder.&.push(YogurtOp.instruction(YogurtInstruction {
        instruction = Instruction.concat_strings, args = list(a, b).to_slice()
      }) $ type_string)
    }
    case crash {
      var message = params.get(0)
      builder.&.push(
        YogurtOp.instruction(YogurtInstruction {
          instruction = Instruction.crash, args = list(message).to_slice()
        }) $ PlumType.never
      )
    }
    case type_of {
      var value = builder.get(params.get(0))
      builder.&.push(yogurt_value_type(value.type).to_expr())
    }
    case type_info
      return error[YogurtId, String]("type_info called on Type that's not comptime")
  )
}
fun compile_cast_fun(
  from: PlumType, to: PlumType, compiler: &YogurtCompiler
): YogurtSignature {
  var signature = yogurt_signature("cast {from} to {to}", empty_slice[PlumType]())

  if compiler.is_defined(signature) or compiler.is_currently_compiling(signature)
  then
    return signature
  compiler.start_compiling(signature)

  var fun_builder = yogurt_fun_builder()
  var body = YogurtBodyBuilder {
    parent = fun_builder.&, body = list[YogurtId]()
  }
  var param = body.parent.&.push(YogurtOp.param $ from)
  var returns = compile_cast_fun_body(from, to, body.&, param, compiler)
  var fun_ = YogurtFun {
    exprs = fun_builder.exprs.to_slice(),
    captures = none[Slice[YogurtId]](),
    body = YogurtBody {
      params = list(param).to_slice(),
      exprs = body.body.to_slice(),
      returns
    }
  }

  compiler.define(signature, fun_)
  compiler.done_compiling()
  signature
}
fun compile_cast_fun_body(
  from: PlumType, to: PlumType,
  builder: &YogurtBodyBuilder, param: YogurtId, compiler: &YogurtCompiler
): YogurtId {
  if from is never then
    return builder.push(YogurtOp.uninitialized $ to)
  if from == to then
    return param | The cast fun is just the identity fun.

  switch to.extend_one_level()
  case struct_(struct_) {
    var cast_fields = map[String, YogurtId]()
    for field in from.extend_one_level().struct_.unwrap() do {
      var name = field.key
      var from_field_type = field.value
      var to_field_type = struct_.get(name)

      var original_id = builder.&.push(YogurtOp.member(YogurtMember {
        of = param, name
      }) $ from_field_type)
      var cast_id = builder.&.push(YogurtOp.call(YogurtCall {
        function = compile_cast_fun(from_field_type, to_field_type, compiler),
        args = list(original_id).to_slice(),
      }) $ to_field_type)

      cast_fields.&.put(name, cast_id)
    }

    builder.push(YogurtOp.struct_(cast_fields) $ to)
  }
  case enum_(to_variants) {
    var cases = map[String, YogurtBody]()
    for entry in from.extend_one_level().enum_.unwrap() do {
      var variant = entry.key
      var from_payloads = entry.value
      var to_payloads = to_variants.get(variant)

      var case_builder = YogurtBodyBuilder {
        parent = builder.parent, body = list[YogurtId]()
      }

      var from_payloads_ids = list[YogurtId]()
      for payload in from_payloads do
        from_payloads_ids.&.push(builder.parent.push(YogurtOp.param $ payload))
      var to_payloads_ids = list[YogurtId]()
      for both in zip(zip(from_payloads.iter(), to_payloads.iter()), from_payloads_ids.iter()) do {
        var from_payload_type = both.a.a
        var to_payload_type = both.a.b
        var from_payload_id = both.b

        to_payloads_ids.&.push(case_builder.&.push(YogurtOp.call(YogurtCall {
          function = compile_cast_fun(from_payload_type, to_payload_type, compiler),
          args = list(from_payload_id).to_slice(),
        }) $ to_payload_type))
      }

      var cast = case_builder.&.push(YogurtOp.variant(YogurtVariant {
        symbol = variant, payloads = to_payloads_ids.to_slice()
      }) $ to)

      var body = YogurtBody {
        params = from_payloads_ids.to_slice(),
        exprs = case_builder.body.to_slice(),
        returns = cast,
      }

      cases.&.put(variant, body)
    }
    builder.push(YogurtOp.switch_(YogurtSwitch { condition = param, cases }) $ to)
  }
  default panic("casting {from} to {to} is not supported")
}
