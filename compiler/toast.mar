| Totally Okay Abstract Syntax Tree  
| Tree that represents the syntactical language constructs. This data structure
| should roughly correspond to the content of Plum files.
| TODO: In the long term, we should move the Toast closer to the original source
| code â€“ for example, by representing pipes and calls differently. This then
| allows us to use the Toast for formatting.

import plum.mar

struct Toast { defs: Slice[ToastDef] }
enum ToastDef { type: ToastTypeDef, fun_: ToastFun }

struct ToastTypeDef {
  name: StringAndSrc, params: Slice[StringAndSrc], type: ToastType
}
enum ToastType {
  variable: StringAndSrc,
  call: ToastTypeCall,
  struct_: Slice[ToastTypeField],
  enum_: Slice[ToastTypeVariant],
  lambda: ToastTypeLambda,
}
struct ToastTypeCall { name: StringAndSrc, args: Slice[ToastType] }
struct ToastTypeField { name: StringAndSrc, type: ToastType }
struct ToastTypeVariant { name: StringAndSrc, payloads: Slice[ToastType] }
struct ToastTypeLambda { args: Slice[ToastType], return_type: &ToastType }

struct ToastFun {
  name: StringAndSrc,
  params: Slice[ToastParam],
  return_type: ToastType,
  body: ToastExpr,
}
struct ToastParam { name: StringAndSrc, type: ToastType }
enum ToastExpr {
  int: IntAndSrc,
  string: StringAndSrc,
  struct_: ToastStruct,
  member: ToastMember,
  symbol: StringAndSrc,
  switch_: ToastSwitch,
  name: StringAndSrc,
  lambda: ToastLambda,
  call: ToastCall,
  var_: ToastVar,
  body: Slice[ToastExpr],
}
struct ToastStruct { ampersand: StringAndSrc, fields: Slice[ToastField] }
struct ToastField { name: StringAndSrc, value: ToastExpr }
struct ToastMember { of: &ToastExpr, name: StringAndSrc }
struct ToastSwitch {
  condition: &ToastExpr, percent: StringAndSrc, cases: Slice[ToastCase]
}
struct ToastCase {
  symbol: StringAndSrc, payloads: Slice[StringAndSrc], body: ToastExpr
}
struct ToastLambda {
  backslash: StringAndSrc, params: Slice[ToastParam], body: &ToastExpr
}
struct ToastCall { function: &ToastExpr, args: Slice[ToastExpr] }
struct ToastVar {
  left: &ToastExpr, equal_sign: StringAndSrc, right: &ToastExpr
}

struct IntAndSrc { int: Int, src: Src }
struct StringAndSrc { string: String, src: Src }

fun @(int: Int, src: Src): _ { IntAndSrc { int, src } }
fun @(string: String, src: Src): _ { StringAndSrc { string, src } }

fun write[W](writer: W, toast: Toast) {
  var first = true
  for def in toast.defs do {
    if first then first = false else writer."\n"
    switch def
    case type(def) {
      writer."{def.name.string}"
      for param in def.params do writer." {param.string}"
      writer." = "
      writer."{def.type}"
    }
    case fun_(def) {
      writer."{def.name.string}"
      for param in def.params do writer." {param.name.string}: {param.type}"
      writer." -> {def.return_type} =\n"
      writer.write(def.body, 1)
    }
  }
}
fun write[W](writer: W, type: ToastType) {
  switch type
  case variable(variable) writer."{variable.string}"
  case call(call) {
    writer."{call.name.string}"
    for arg in call.args do writer." {arg}"
  }
  case struct_(fields) {
    writer."&"
    for field in fields do
      writer." {field.name.string}: {field.type.without_whitespace()}"
  }
  case enum_(variants) {
    writer."|"
    for variant in variants do {
      writer." "
      if variant.args.is_not_empty() then writer."("
      writer."{variant.name.string}"
      for arg in variant.args do writer." {arg.without_whitespace()}"
      if variant.args.is_not_empty() then writer.")"
    }
  }
  case lambda(lambda) {
    writer."\\"
    for arg in lambda.args do writer." {arg.without_whitespace()}"
    writer." -> {lambda.return_type.without_whitespace()}"
  }
}
fun write[W](writer: W, type: FormatWithoutWhitespace[ToastType]) {
  switch type.value
  case variable(variable) writer."{variable}"
  case call(call) writer."({call})"
  case struct_(struct_) writer."({struct_})"
  case enum_(enum_) writer."({enum_})"
  case lambda(lambda) writer."({lambda})"
}
fun write[W](writer: W, body: Slice[ToastExpr], indentation: Indentation) {
  var first = true
  for expr in body do {
    if first then first = false else writer."\n"
    writer.write(expr, indentation)
  }
}
fun write[W](writer: W, expr: ToastExpr, indentation: Indentation) {
  switch expr.kind
  case int(int) writer."{indentation}{int.int}"
  case string(string) writer."{indentation}{string.string.debug()}"
  case struct_(struct_) {
    var is_first = true
    for field in struct_ do {
      writer."{indentation}{if is_first then "& " else "  "}{field.name.string}:\n"
      writer.write(field.value, indentation + 2)
      is_first = false
    }
    if struct_.is_empty() then writer."{indentation}&"
  }
  case member(member) {
    writer.write(member.of.*, indentation)
    writer."\n{indentation}.{member.name.string}"
  }
  case symbol(symbol) writer."{symbol.string}"
  case switch_(switch_) {
    writer.write(switch_.condition.*, indentation)
    var is_first = true
    for case_ in switch_.cases do {
      writer."\n{indentation}{if is_first then "% " else "  "}
        '{case_.symbol.string}:\n"
      writer.write(case_.body, indentation + 2)
      is_first = false
    }
  }
  case name(name) writer."{indentation}{name.string}"
  case lambda(lambda) {
    writer."{indentation}\\"
    for param in lambda.params do writer." {param}"
    writer." =\n"
    writer.write(lambda.body.*, indentation + 1)
  }
  case call(call) {
    writer.write(call.function.*, indentation)
    writer."\n"
    writer.write(call.args, indentation + 1)
  }
  case var_(var_) {
    writer."{indentation}{var_.name} =\n"
    writer.write(var_.value.*, indentation + 1)
  }
  case body(body) writer.write(body, indentation)
}

fun src(expr: ToastExpr): Src {
  switch expr
  case int(int) int.src
  case string(string) string.src
  case struct_(struct_) {
    struct_.ampersand.src ...
      if struct_.fields.last_maybe() is some(field) then
        field.value.src()
      else
        struct_.ampersand.src
  }
  case member(member) member.of.src() ... member.name.src
  case symbol(symbol) symbol.src
  case switch_(switch_) {
    switch_.percent.src ...
      if switch_.cases.last_maybe() is some(case_) then
        case_.body.src()
      else
        switch_.percent.src
  }
  case name(name) name.src
  case lambda(lambda) lambda.backslash.src ... lambda.body.src()
  case call(call) call.function.src() ... call.args.last().src()
  case var_(var_) var_.left.src() ... var_.right.src()
  case body(body) body.first().src() ... body.last().src()
}
