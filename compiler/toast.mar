| Totally Okay Abstract Syntax Tree  
| Tree that represents the syntactical language constructs. This data structure
| should roughly correspond to the content of Plum files.
| TODO: In the long term, we should move the Toast closer to the original source
| code â€“ for example, by representing pipes and calls differently. This then
| allows us to use the Toast for formatting. Then, we should be able to not save
| the Src in every tree node, but only in the leaves.

import plum.mar

struct Toast { defs: Slice[ToastDef] }
enum ToastDef { type: ToastTypeDef, fun_: ToastFun }

struct ToastTypeDef {
  name: StringAndSrc, params: Slice[StringAndSrc], type: ToastType
}
enum ToastType {
  variable: StringAndSrc,
  call: ToastTypeCall,
  struct_: List[ToastTypeField],
  enum_: List[ToastTypeCase],
  lambda: ToastTypeLambda,
}
struct ToastTypeCall { name: StringAndSrc, args: Slice[ToastType] }
struct ToastTypeField { name: StringAndSrc, type: ToastType }
struct ToastTypeCase { name: StringAndSrc, args: Slice[ToastType] }
struct ToastTypeLambda { args: Slice[ToastType], return_type: &ToastType }

struct ToastFun {
  name: StringAndSrc,
  params: Slice[ToastParam],
  return_type: ToastType,
  body: ToastExpr,
}
struct ToastParam { name: StringAndSrc, type: ToastType }
struct ToastExpr { kind: ToastExprKind, src: Src }
enum ToastExprKind {
  int: Int,
  string: String,
  struct_: Slice[ToastField],
  member: ToastMember,
  symbol: String,
  switch_: ToastSwitch,
  name: String,
  lambda: ToastLambda,
  call: ToastCall,
  var_: ToastVar,
  body: Slice[ToastExpr],
}
struct ToastField { name: StringAndSrc, value: ToastExpr }
struct ToastMember { of: &ToastExpr, name: StringAndSrc }
struct ToastSwitch { condition: &ToastExpr, cases: Slice[ToastCase] }
struct ToastCase { symbol: StringAndSrc, params: Slice[StringAndSrc], body: ToastExpr }
struct ToastLambda { params: Slice[ToastParam], body: &ToastExpr }
struct ToastCall { receiver: &ToastExpr, args: Slice[ToastExpr] }
struct ToastVar { name: String, value: &ToastExpr }

struct StringAndSrc { string: String, src: Src }

fun @(kind: ToastExprKind, src: Src): ToastExpr { ToastExpr { kind, src } }
fun @(string: String, src: Src): _ { StringAndSrc { string, src } }

fun write[W](writer: W, toast: Toast) {
  var first = true
  for def in toast.defs do {
    if first then first = false else writer."\n"
    switch def
    case type(def) {
      writer."{def.name.string}"
      for param in def.params do writer." {param.string}"
      writer." = "
      writer."{def.type}"
    }
    case fun_(def) {
      writer."{def.name.string}"
      for param in def.params do writer." {param.name.string}: {param.type}"
      writer." -> {def.return_type}"
      writer." =\n"
      writer.write(def.body, 1)
    }
  }
}
fun write[W](writer: W, type: ToastType) {
  switch type
  case variable(variable) writer."{variable.string}"
  case call(call) {
    writer."({call.name.string}"
    for arg in call.args do writer." {arg}"
    writer.")"
  }
  case struct_(fields) {
    writer."&"
    for field in fields do writer." {field.name.string}: {field.type}"
  }
  case enum_(variants) {
    writer."|"
    for variant in variants do {
      writer." ({variant.name.string}"
      for arg in variant.args do writer." {arg}"
      writer.")"
    }
  }
  case lambda(lambda) {
    writer."(\\"
    for arg in lambda.args do writer." {arg}"
    writer." -> {lambda.return_type})"
  }
}
fun write[W](writer: W, body: Slice[ToastExpr], indentation: Int) {
  var first = true
  for expr in body do {
    if first then first = false else writer."\n"
    writer.write(expr, indentation)
  }
}
fun write[W](writer: W, expr: ToastExpr, indentation: Int) {
  if not(expr.kind is body) then
    for i in 0..indentation do writer."  "
  switch expr.kind
  case int(int) writer."{int} @ {expr.src}"
  case string(str) writer."\"{str}\""
  case struct_(fields) {
    var is_first = true
    for field in fields do {
      writer."{if is_first then "& " else "  "}{field.name.string}: \n"
      writer.write(field.value, indentation + 2)
      is_first = false
    }
    if fields.is_empty() then writer."&"
  }
  case member(member) {
    writer."member {member.name.string}"
    writer.write(member.of.*, indentation + 1)
  }
  case symbol(symbol) writer."{symbol}"
  case switch_(switch_) {
    writer."%\n"
    writer.write(switch_.condition.*, indentation + 1)
    for case_ in switch_.cases do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {case_.symbol.string}:\n"
      writer.write(case_.body, indentation + 2)
    }
  }
  case name(name) writer."{name}"
  case lambda(lambda) {
    writer."\\"
    for param in lambda.params do writer." {param.name.string}: {param.type}"
    writer." =\n"
    writer.write(lambda.body.*, indentation + 1)
  }
  case call(call) {
    writer."call\n"
    writer.write(call.receiver.*, indentation + 1)
    writer."\n"
    writer.write(call.args, indentation + 1)
  }
  case var_(var_) {
    writer."var {var_.name} =\n"
    writer.write(var_.value.*, indentation + 1)
  }
  case body(body) writer.write(body, indentation)
}

| In this file, parsing refers to converting a single line of code into
| something toasty.

struct Parser { input: String, input_src: Src, cursor: Int }
fun parser(input: String, src: Src): _ {
  Parser { input, input_src = src, cursor = 0 }
}
fun src_of(parser: Parser, cursor_range: Range[Int]): Src {
  var start_offset = parser.input_src.range.start
  parser.input_src.with_range(
    {start_offset + cursor_range.start}..{start_offset + cursor_range.end}
  )
}
fun src_from_until_cursor(parser: Parser, start: Int): Src {
  parser.src_of(start..parser.cursor)
}
fun src_of_rest(parser: Parser): Src {
  parser.input_src.with_range(
    {parser.input_src.range.start + parser.cursor}..parser.input_src.range.end
  )
}
fun current(parser: Parser): Char {
  parser.input.chars().get_maybe(parser.cursor) or 0.lower_byte().to_char()
}
fun advance(parser: &Parser) { parser.cursor = parser.cursor + 1 }
fun is_at_end(parser: Parser): Bool { parser.cursor == parser.input.len }
fun consume_whitespace(parser: &Parser) {
  loop {
    parser.current().is_whitespace() or break
    parser.advance()
  }
}
fun is_done(parser: &Parser): Bool {
  parser.consume_whitespace()
  parser.is_at_end()
}
fun consume(parser: &Parser, char: Char): Maybe[Src] {
  parser.consume_whitespace()
  parser.current() == char or return none[Src]()
  var src = parser.input_src.with_range(
    {parser.input_src.range.start + parser.cursor} ..+ 1)
  parser.advance()
  some(src)
}
fun consume(parser: &Parser, prefix: String): Maybe[Src] {
  parser.consume_whitespace()
  var start = parser.cursor
  for char in prefix.chars() do {
    parser.current() == char or {
      parser.cursor = start
      return none[Src]()
    }
    parser.advance()
  }
  some(
    parser.input_src.with_range({parser.input_src.range.start + start} ..+ 1)
  )
}
fun parse_int(parser: &Parser): Maybe[Int] {
  parser.consume_whitespace()
  var num = 0
  var start = parser.cursor
  loop {
    var char = parser.current()
    char.is_digit() or break
    num = num * 10 + {char - #0}.to_int()
    parser.advance()
  }
  if start == parser.cursor then return none[Int]()
  some(num)
}

fun no_match[T](): Result[Maybe[T], Error] {
  ok[Maybe[T], Error](none[T]())
}
fun bad_input[T](error: Error): Result[Maybe[T], Error] {
  error[Maybe[T], Error](error)
}
fun parsed[T](value: T): Result[Maybe[T], Error] {
  ok[Maybe[T], Error](some(value))
}

fun parse_string(parser: &Parser): Result[Maybe[String], Error] {
  parser.consume(#") or return no_match[String]()
  var start = parser.cursor
  loop {
    if parser.is_at_end() then
      return bad_input[String](error(
        "string doesn't end until end of input", parser.src_of_rest()
      ))
    if parser.current() == #" then break
    parser.advance()
  }
  var end = parser.cursor
  parser.advance() | consume the "
  parsed(parser.input.substr(start..end))
}
var identifier_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+-*/<>"
fun parse_identifier(parser: &Parser): Maybe[StringAndSrc] {
  parser.consume_whitespace()
  var start = parser.cursor
  loop {
    identifier_chars.iter().&.contains(parser.current()) or break
    parser.advance()
  }
  var end = parser.cursor
  if start == end then return none[StringAndSrc]()
  var identifier = parser.input.substr(start..end)
  if identifier == "->" then {
    parser.cursor = start
    return none[StringAndSrc]()
  }
  some(identifier @ parser.src_of(start..end))
}
fun parse_name(parser: &Parser): Maybe[StringAndSrc] {
  parser.consume_whitespace()
  not(parser.current().is_upper()) or return none[StringAndSrc]()
  parser.parse_identifier()
}
fun parse_symbol(parser: &Parser): Maybe[StringAndSrc] {
  parser.consume_whitespace()
  parser.current().is_upper() or return none[StringAndSrc]()
  parser.parse_identifier()
}
| Parses an expression that doesn't include whitespace (except in parentheses).
fun parse_atom(parser: &Parser): Result[Maybe[ToastExpr], Error] {
  var start = parser.cursor
  var expr =
    if parser.consume(#() is some(paren_src) then {
      var expr = parser.parse_expr()? or
        return bad_input[ToastExpr](error(
          "Expected expression after parenthesis.", paren_src
        ))
      parser.consume(#)) or
        return bad_input[ToastExpr](error(
          "Expected the closing parenthesis.",
          parser.src_of_rest()
        ))
      expr
    } else if parser.parse_int() is some(int) then
      ToastExprKind.int(int) @ parser.src_from_until_cursor(start)
    else if parser.parse_string()? is some(str) then
      ToastExprKind.string(str) @ parser.src_from_until_cursor(start)
    else if parser.parse_name() is some(name) then
      ToastExprKind.name(name.string) @ name.src
    else if parser.parse_symbol() is some(symbol) then
      ToastExprKind.symbol(symbol.string) @ symbol.src
    else return no_match[ToastExpr]()

  loop {
    parser.consume(#.) or break
    var name = parser.parse_name() or
      return bad_input[ToastExpr](error(
        "Expected name of the field", parser.src_of_rest()
      ))
    expr = ToastExprKind.member(ToastMember {
      of = expr.put_on_heap(), name
    }) @ {expr.src ... name.src}
  }

  parsed(expr)
}
| Parses an expression that doesn't contain pipes (except in parentheses).
fun parse_unpiped_expr(parser: &Parser): Result[Maybe[ToastExpr], Error] {
  | if parser.parse_lambda()? is some(lambda) then return parsed(lambda)

  var expr = parser.parse_atom()? or return no_match[ToastExpr]()

  var args = list[ToastExpr]()
  loop args.&.push(parser.parse_atom()? or break)
  if args.is_not_empty() then
    expr = ToastExprKind.call(ToastCall {
      receiver = expr.put_on_heap(), args = args.to_slice()
    }) @ {expr.src ... args.last().src}

  parsed(expr)
}
fun parse_expr(parser: &Parser): Result[Maybe[ToastExpr], Error] {
  var expr = parser.parse_unpiped_expr()? or return no_match[ToastExpr]()

  loop {
    parser.consume(#|) or break
    var piped_into = parser.parse_unpiped_expr()? or
      return bad_input[ToastExpr](error(
        "Expected expression", parser.src_of_rest()
      ))
    expr = piped_call(expr, piped_into)
  }
  if parser.consume(#=) is some(equals_src) then {
    var cursor_after_equals_sign = parser.cursor
    if parser.parse_expr()? is some(value) then
      expr = ToastExprKind.var_(create_var(expr, value, equals_src)?)
        @ {expr.src ... value.src}
    else
      parser.cursor = cursor_after_equals_sign - 1
  }

  parsed(expr)
}
| fun parse_lambda(parser: &Parser): Result[Maybe[ToastLambda], Error] {
|   parser.consume("\\") or return no_match[ToastLambda]()

|   var params = list[ToastParam]()
|   loop params.&.push(parser.&.parse_param()? or break)

|   parser.consume("=") or
|     return bad_input[ToastLambda](error(
|       "Expected equals sign.", parser.src_of_rest()
|     ))
| }

fun parse_type_atom(parser: &Parser): Result[Maybe[ToastType], Error] {
  if parser.consume(#() is some(paren_src) then {
    var type = parser.parse_type_expr()? or
      return bad_input[ToastType](error(
        "Expected expression after parenthesis.", paren_src
      ))
    parser.consume(#)) or
      return bad_input[ToastType](error(
        "Expected a closing parenthesis.", parser.src_of_rest()
      ))
    return parsed(type)
  }
  if parser.parse_symbol() is some(name) then
    return parsed(ToastType.call(ToastTypeCall {
      name, args = empty_slice[ToastType]()
    }))
  if parser.parse_name() is some(name) then
    return parsed(ToastType.variable(name))
  no_match[ToastType]()
}
fun parse_type_expr(parser: &Parser): Result[Maybe[ToastType], Error] {
  if parser.consume("\\") is some then {
    var args = list[ToastType]()
    loop args.&.push(parser.parse_type_atom()? or break)
    parser.consume("->") or
      return bad_input[ToastType](error(
        "Expected lambda arrow ->.", parser.src_of_rest()
      ))
    var return_type = parser.parse_type_atom()? or
      return bad_input[ToastType](error(
        "Expected the lambda return type.", parser.src_of_rest()
      ))
    return parsed(ToastType.lambda(ToastTypeLambda {
      args = args.to_slice(), return_type = return_type.put_on_heap(),
    }))
  }
  if parser.parse_symbol() is some(name) then {
    var args = list[ToastType]()
    loop args.&.push(parser.parse_type_atom()? or break)
    return parsed(ToastType.call(ToastTypeCall { name, args = args.to_slice() }))
  }
  if parser.parse_type_atom()? is some(type) then return parsed(type)
  no_match[ToastType]()
}

fun create_var(
  left: ToastExpr, right: ToastExpr, equals_src: Src
): Result[ToastVar, Error] {
  switch left.kind
  case name(name)
    ok[ToastVar, Error](ToastVar { name, value = right.put_on_heap() })
  default
    error[ToastVar, Error](error(
      "variables can only have a name on the left side", equals_src
    ))
}

fun to_toast_type(bacon: Bacon): Result[ToastType, Error] {
  if bacon.line == "&" then {
    var fields = list[ToastTypeField]()
    for field in bacon.children do {
      var parser = parser(field.line, field.src)
      var name = parser.&.parse_name() or
        return error[ToastType, Error](error(
          "Expected field name.", parser.src_of_rest()
        ))
      parser.&.consume(":") or
        return error[ToastType, Error](error(
          "Expected colon after field name.", parser.src_of_rest()
        ))
      var type =
        if field.children.is_empty() then {
          var type = parser.&.parse_type_expr()? or
            return error[ToastType, Error](error(
              "Expected type of field.", parser.src_of_rest()
            ))
          parser.&.is_done() or
            return error[ToastType, Error](error(
              "Additional garbage on line.", parser.src_of_rest()
            ))
          type
        } else {
          parser.&.is_done() or
            return error[ToastType, Error](error(
              "Additional garbage on line.", parser.src_of_rest()
            ))
          var children = field.children.to_toast_types()?
          children.len == 1 or
            return error[ToastType, Error](error(
              "Fields can only have one type.", parser.src_of_rest()
            ))
          children.get(0)
        }
      fields.&.push(ToastTypeField { name, type })
    }
    ok[ToastType, Error](ToastType.struct_(fields))
  } else if bacon.line == "|" then {
    var variants = list[ToastTypeCase]()
    for variant in bacon.children do {
      var parser = parser(variant.line, variant.src)
      var name = parser.&.parse_symbol() or
        return error[ToastType, Error](error(
          "Expected variant name.", parser.src_of_rest()
        ))
      var args =
        if variant.children.is_empty() then {
          var args = list[ToastType]()
          loop args.&.push(parser.&.parse_type_atom()? or break)
          parser.&.is_done() or
            return error[ToastType, Error](error(
              "Additional garbage on line.", parser.src_of_rest()
            ))
          args.to_slice()
        } else {
          parser.&.is_done() or
            return error[ToastType, Error](error(
              "Additional garbage on line.", parser.src_of_rest()
            ))
          variant.children.to_toast_types()?
        }
      variants.&.push(ToastTypeCase { name, args })
    }
    ok[ToastType, Error](ToastType.enum_(variants))
  } else {
    var parser = parser(bacon.line, bacon.src)
    if bacon.children.is_empty() then {
      var type = parser.&.parse_type_expr()? or
        return error[ToastType, Error](error(
          "expected type expr", parser.src_of_rest()
        ))
      parser.&.is_done() or
        return error[ToastType, Error](error(
          "Additional garbage on line", parser.src_of_rest()
        ))
      ok[ToastType, Error](type)
    } else {
      var name = parser.&.parse_symbol() or
        return error[ToastType, Error](error(
          "Expected type symbol (coz children)", parser.src_of_rest()
        ))
      parser.&.is_done() or
        return error[ToastType, Error](error(
          "Additional garbage on line", parser.src_of_rest()
        ))
      var args = bacon.children.to_toast_types()?
      ok[ToastType, Error](ToastType.call(ToastTypeCall { name, args }))
    }
  }
}
fun to_toast_types(bacons: Slice[Bacon]): Result[Slice[ToastType], Error] {
  var types = list[ToastType]()
  for bacon in bacons do types.&.push(bacon.to_toast_type()?)
  ok[Slice[ToastType], Error](types.to_slice())
}
fun to_toast_type_def(bacon: Bacon): Result[Maybe[ToastTypeDef], Error] {
  var parser = parser(bacon.line, bacon.src)
  var name = parser.&.parse_symbol() or return no_match[ToastTypeDef]()
  var params = list[StringAndSrc]()
  loop params.&.push(parser.&.parse_name() or break)
  parser.&.consume(#=) or
    return bad_input[ToastTypeDef](error(
      "expected = after type signature", parser.src_of_rest()
    ))
  var type =
    if bacon.children.is_empty() then {
      var type = parser.&.parse_type_expr()? or
        return bad_input[ToastTypeDef](error(
          "Expected type expression.", parser.src_of_rest()
        ))
      parser.&.is_done() or
        return bad_input[ToastTypeDef](error(
          "Additional garbage on line.", parser.src_of_rest()
        ))
      type
    } else {
      parser.&.is_done() or
        return bad_input[ToastTypeDef](error(
          "Additional garbage on line.", parser.src_of_rest()
        ))
      bacon.children.len == 1 or
        return bad_input[ToastTypeDef](error(
          "Type definition, but it has {bacon.children.len} children.",
          bacon.children.first().src ... bacon.children.last().src,
        ))
      bacon.children.get(0).to_toast_type()?
    }
  parsed(ToastTypeDef { name, params = params.to_slice(), type })
}

fun to_toast_expr(bacon: Bacon): Result[Maybe[ToastExpr], Error] {
  if bacon.to_toast_struct()? is some(expr) then return parsed(expr)
  if bacon.parse_lambda()? is some(lambda) then return parsed(lambda)

  var parser = parser(bacon.line, bacon.src)
  if parser.&.consume(##) is some then return no_match[ToastExpr]()
  var expr = parser.&.parse_expr()? or
    return bad_input[ToastExpr](error(
      "Expected expression", parser.src_of_rest()
    ))
  var children = bacon.children.to_toast_exprs()?
  if parser.&.consume(#=) is some(equals_src) then {
    if children.is_empty() then return bad_input[ToastExpr](error(
      "Expected a body.", equals_src
    ))
    var body_src = children.first().src ... children.last().src
    expr = ToastExprKind.var_(
      create_var(expr, ToastExprKind.body(children) @ body_src, equals_src)?
    ) @ {expr.src ... children.last().src}
  } else if children.is_not_empty() then
    expr = ToastExprKind.call(ToastCall {
      receiver = expr.put_on_heap(), args = children
    }) @ {expr.src ... children.last().src}
  parser.&.is_done() or
    return bad_input[ToastExpr](error(
      "Additional garbage on line.", parser.src_of_rest()
    ))
  parsed(expr)
}
fun to_toast_struct(bacon: Bacon): Result[Maybe[ToastExpr], Error] {
  bacon.line == "&" or return no_match[ToastExpr]()
  var fields = list[ToastField]()
  for field in bacon.children do {
    var parser = parser(field.line, field.src)
    var name = parser.&.parse_name() or
      return bad_input[ToastExpr](error(
        "Expected field name.", parser.src_of_rest()
      ))
    parser.&.consume(":") or
      return bad_input[ToastExpr](error(
        "Expected colon after field name.", parser.src_of_rest()
      ))
    var value =
      if field.children.is_empty() then {
        var value = parser.&.parse_expr()? or
          return bad_input[ToastExpr](error(
            "Expected value of field.", parser.src_of_rest()
          ))
        parser.&.is_done() or
          return bad_input[ToastExpr](error(
            "Additional garbage on line.", parser.src_of_rest()
          ))
        value
      } else {
        parser.&.is_done() or
          return bad_input[ToastExpr](error(
            "Additional garbage on line.", parser.src_of_rest()
          ))
        var children = field.children.to_toast_exprs()?
        children.len == 1 or
          return bad_input[ToastExpr](error(
            "Fields can only have one value.", parser.src_of_rest()
          ))
        children.get(0)
      }
    fields.&.push(ToastField { name, value })
  }
  parsed(
    ToastExprKind.struct_(fields.to_slice())
      @ {bacon.src ... fields.last().value.src}
  )
}
fun parse_lambda(bacon: Bacon): Result[Maybe[ToastExpr], Error] {
  var parser = parser(bacon.line, bacon.src)
  var backslash_src = parser.&.consume("\\") or return no_match[ToastExpr]()

  var params = list[ToastParam]()
  loop params.&.push(parser.&.parse_param()? or break)

  var equals_src = parser.&.consume("=") or
    return bad_input[ToastExpr](error(
      "Expected equals sign.", parser.src_of_rest()
    ))

  var body =
    if bacon.children.is_empty() then {
      var body = parser.&.parse_expr()? or
        return bad_input[ToastExpr](error(
          "Expected body of the lambda.", parser.src_of_rest()
        ))
      parser.&.is_done() or
        return bad_input[ToastExpr](error(
          "Additional garbage on line after lambda body.", parser.src_of_rest()
        ))
      body
    } else {
      parser.&.is_done() or
        return bad_input[ToastExpr](error(
          "Additional garbage on line.", parser.src_of_rest()
        ))
      var children = bacon.children.to_toast_exprs()?
      if children.is_empty() then
        return bad_input[ToastExpr](error("Expected lambda body.", equals_src))
      var body_src = children.first().src ... children.last().src
      ToastExprKind.body(children) @ body_src
    }

  parsed(ToastExprKind.lambda(ToastLambda {
    params = params.to_slice(),
    body = body.put_on_heap(),
  }) @ {backslash_src ... body.src})
}
fun parse_switch(
  bacon: Bacon, condition: ToastExpr
): Result[Maybe[ToastExpr], Error] {
  bacon.line == "%" or return no_match[ToastExpr]()
  var cases = list[ToastCase]()
  for case_ in bacon.children do {
    var parser = parser(case_.line, case_.src)
    var symbol = parser.&.parse_symbol() or
      return bad_input[ToastExpr](error(
        "Expected the symbol of a case.", parser.src_of_rest()
      ))
    var params = list[StringAndSrc]()
    loop params.&.push(parser.&.parse_name() or break)
    var colon_src = parser.&.consume(#:) or
      return bad_input[ToastExpr](error(
        "Expected a colon.", parser.src_of_rest()
      ))
    var body =
      if parser.cursor == parser.input.len then {
        var children = case_.children.to_toast_exprs()?
        if children.is_empty() then
          return bad_input[ToastExpr](error(
          "Expected the body of the case.", colon_src,
        ))
        var body_src = {children.first().src ... children.last().src}
        ToastExprKind.body(children) @ body_src
      } else {
        var expr = parser.&.parse_expr()? or
          return bad_input[ToastExpr](error(
            "Expected a case expression.", parser.src_of_rest()
          ))
        parser.&.is_done() or
          return bad_input[ToastExpr](error(
            "There's additional garbage on a case line.", parser.src_of_rest()
          ))
        case_.children.is_empty() or
          return bad_input[ToastExpr](error(
            "A case is neither single- nor multi-line.", parser.src_of_rest()
          ))
        expr
      }
    cases.&.push(ToastCase { symbol, params = params.to_slice(), body })
  }
  parsed(ToastExprKind.switch_(ToastSwitch {
    condition = condition.put_on_heap(), cases = cases.to_slice()
  }) @ {bacon.src ... if cases.is_empty() then bacon.src else cases.last().body.src})
}
fun parse_pipe(
  bacon: Bacon, previous: ToastExpr
): Result[Maybe[ToastExpr], Error] {
  bacon.line == "|" or return no_match[ToastExpr]()
  var children = bacon.children.to_toast_exprs()?
  children.len == 1 or
    return bad_input[ToastExpr](error(
      "Pipe with multiple children",
      bacon.src.with_range(bacon.src.range.start..{bacon.src.range.start + 1})
    ))
  var piped_into = children.get(0)
  parsed(piped_call(previous, piped_into))
}
fun piped_call(left: ToastExpr, piped_into: ToastExpr): ToastExpr {
  if piped_into.kind is call(call) then {
    var args = list(left)
    for arg in call.args do args.&.push(arg)
    ToastExprKind.call(ToastCall {
      receiver = call.receiver, args = args.to_slice()
    }) @ {left.src ... piped_into.src}
  } else
    ToastExprKind.call(ToastCall {
      receiver = piped_into.put_on_heap(), args = list(left).to_slice()
    }) @ {left.src ... piped_into.src}
}
fun to_toast_exprs(bacons: Slice[Bacon]): Result[Slice[ToastExpr], Error] {
  var exprs = list[ToastExpr]()
  var i = 0
  loop {
    var bacon = bacons.get_maybe(i) or break
    var expr = bacon.to_toast_expr()? or { i = i + 1  continue }

    loop {
      var next = bacons.get_maybe(i + 1) or break
      if      next.parse_switch(expr)? is some(new) then { expr = new }
      else if next.parse_pipe(expr)?   is some(new) then { expr = new }
      else break
      i = i + 1
    }

    exprs.&.push(expr)
    i = i + 1
  }
  ok[Slice[ToastExpr], Error](exprs.to_slice())
}
fun to_toast_fun_def(bacon: Bacon): Result[Maybe[ToastFun], Error] {
  var parser = parser(bacon.line, bacon.src)
  var name = parser.&.parse_name() or return no_match[ToastFun]()
  var params = list[ToastParam]()
  loop params.&.push(parser.&.parse_param()? or break)
  parser.&.consume("->") or
    return bad_input[ToastFun](error(
      "Expected ->", parser.src_of_rest()
    ))
  var return_type = parser.&.parse_type_atom()? or
    return bad_input[ToastFun](error(
      "expected return type",
      parser.src_of_rest()
    ))
  var equals_src = parser.&.consume(#=) or
    return bad_input[ToastFun](error(
      "expected =", parser.src_of_rest()
    ))

  var body =
    if bacon.children.is_empty() then {
      var body = parser.&.parse_expr()? or
        return bad_input[ToastFun](error(
          "Expected fun body.", parser.src_of_rest()
        ))
      parser.&.is_done() or
        return bad_input[ToastFun](error(
          "Additional garbage on line.", parser.src_of_rest()
        ))
      body
    } else {
      var children = bacon.children.to_toast_exprs()?
      if children.is_empty() then
        return bad_input[ToastFun](error("Expected function body.", equals_src))
      var body_src = children.first().src ... children.last().src
      ToastExprKind.body(children) @ body_src
    }

  parsed(ToastFun { name, params = params.to_slice(), return_type, body })
}
fun parse_param(parser: &Parser): Result[Maybe[ToastParam], Error] {
  var name = parser.parse_name() or return no_match[ToastParam]()
  parser.consume(#:) or
    return bad_input[ToastParam](error(
      "Expected : after param {name.string}.", name.src
    ))
  var type = parser.&.parse_type_atom()? or
    return bad_input[ToastParam](error(
      "Expected type of param {name.string}", name.src
    ))
  parsed(ToastParam { name, type })
}

fun to_toast(bacon: Bacon): Result[Toast, Error] {
  bacon.line.is_empty() or panic("to_toast was given non-root Bacon")

  var defs = list[ToastDef]()
  for bacon in bacon.children do {
    if bacon.to_toast_type_def()? is some(def) then {
      defs.&.push(ToastDef.type(def))
      continue
    }
    if bacon.to_toast_fun_def()? is some(def) then {
      defs.&.push(ToastDef.fun_(def))
      continue
    }
    if bacon.line.starts_with("#") then continue

    return error[Toast, Error](error("Couldn't parse line.", bacon.src))
  }

  ok[Toast, Error](Toast { defs = defs.to_slice() })
}
