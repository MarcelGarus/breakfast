| Expression-Guided Graph  
| A representation of code that is simplified and more suitable for
| type-checking.
|
| Types:
|   Names of types are resolved. Usages of type definitions (which are more like
|   aliases anyway) have been resolved so that types have no names anymore –
|   they are completely structural.
|
| Functions:
|   Names of locals and types are resolved. Function calls are not resolved to
|   specific functions yet, as this requires overloading resolution. Nested
|   expressions in function bodies have been flattened to a series of small
|   expressions.

import plum.mar

struct Egg { funs: List[EggFun] }

struct EggFun {
  name: StringAndSrc, params: Slice[EggParam], return_type: PlumType,
  impl: EggFunImpl
}
struct EggParam { name: String, type: PlumType }
enum EggFunImpl { code: EggCode, builtin: Builtin }
struct EggCode { exprs: Slice[EggExpr], body: EggBody }
struct EggId { int: Int }
struct EggBody { params: Slice[EggId], exprs: Slice[EggId], returns: EggId }

struct EggExpr { kind: EggExprKind, src: Src }
enum EggExprKind {
  param,
  int: Int,
  string: String,
  struct_: Map[String, EggId],
  member: EggMember,
  symbol: String,
  tag: EggTag,
  switch_: EggSwitch,
  lambda: EggLambda,
  lambda_call: EggLambdaCall,
  call: EggCall,
}
struct EggMember { of: EggId, name: String }
struct EggSwitch { condition: EggId, cases: Map[String, EggBody] }
struct EggTag { symbol: String, args: Slice[EggId] }
struct EggLambda { params: Slice[EggParam], body: EggBody }
struct EggLambdaCall { lambda: EggId, args: Slice[EggId] }
struct EggCall { receiver: StringAndSrc, args: Slice[EggId] }

fun /(name: String, type: PlumType): EggParam { EggParam { name, type } }

fun @(kind: EggExprKind, src: Src): EggExpr { EggExpr { kind, src } }

fun ==(a: EggId, b: EggId): Bool { a.int == b.int }
fun hash(hasher: &Hasher, id: EggId) { hasher.hash(id.int) }

fun get(code: EggCode, id: EggId): EggExpr { code.exprs.get(id.int) }

fun write[W](writer: W, egg: Egg) {
  var first = true
  for fun_ in egg.funs do {
    if first then first = false else writer."\n"
    writer."{fun_.name.string}"
    for param in fun_.params do writer." {param}"
    writer." -> {fun_.return_type} ="
    switch fun_.impl
    case code(code) writer.write(code.body, code, 1)
    case builtin(builtin) writer." ..."
  }
}
fun write[W](writer: W, id: EggId) { writer."@{id.int}" }
fun write[W](writer: W, body: EggBody, code: EggCode, indentation: Int) {
  for param in body.params do writer." {param}"
  writer."\n"
  for id in body.exprs do {
    for i in 0..indentation do writer."  "
    writer."{id} = "
    writer.write(code.get(id), code, indentation)
    writer."\n"
  }
  for i in 0..indentation do writer."  "
  writer."{body.returns}"
}
fun write[W](writer: W, param: EggParam) {
  writer."{param.name}: {param.type}"
}
fun write[W](writer: W, expr: EggExpr, code: EggCode, indentation: Int) {
  switch expr.kind
  case param(param) writer."param {param}"
  case int(int) writer."int {int}"
  case string(string) writer."string {string.debug()}"
  case struct_(struct_) {
    writer."&"
    for field in struct_ do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {field.key}: {field.value}"
    }
  }
  case member(member) writer."{member.of}.{member.name}"
  case symbol(symbol) writer."symbol {symbol}"
  case tag(tag) {
    writer."tag {tag.symbol}"
    for arg in tag.args do writer." {arg}"
  }
  case switch_(switch_) {
    writer."switch {switch_.condition}"
    for case_ in switch_.cases do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {case_.key}:"
      writer.write(case_.value, code, indentation + 2)
    }
  }
  case lambda(lambda) {
    writer."lambda"
    for param in lambda.params do writer." {param}"
    writer." ="
    writer.write(lambda.body, code, indentation + 1)
  }
  case lambda_call(call) {
    writer."call {call.lambda}"
    for arg in call.args do writer." {arg}"
  }
  case call(call) {
    writer."call {call.receiver.string}"
    for arg in call.args do writer." {arg}"
  }
}


| Type Algorithms  
| Turns out, some of the things we want to do with types are not trivial because
| of recursive types. For example, joining these two enums results in a mess:
|
| | Foo (| Bar ^2) = | Foo (| Bar (| Foo (| Bar (...))))
| | Foo ^1         = | Foo (| Foo (| Foo (| Foo (...))))
|
| The joined type is this:
|
| | Foo (| Foo (| Foo ^1) Bar (| Foo (| Bar ^2)))
|
| Basically, the top-level is always the Foo variant and the level below that
| decides whether it is Foo forever or whether Foo and Bar alternate.


| Variable Scoping  
| Tracks which names are in scope using a simple vector:
| - When new names are defined, appends items to the vector.
| - When names are referenced, walks the vector from the back, searching for the
|   name. Names that are defined later shadow previously defined names.
| - When bodies are compiled, save the length of the vector before entering the
|   body. When exiting the body, trim the vector to that length – all names
|   defined inside the body automatically go out of scope.

struct Visible { vars: List[NameBinding] }
struct NameBinding { name: String, id: EggId }
fun visible(): _ { Visible { vars = list[NameBinding]() } }
fun define(visible: &Visible, name: String, id: EggId) {
  visible.vars.&.push(NameBinding { name, id })
}
fun lookup(visible: Visible, name: String): Maybe[EggId] {
  for binding in visible.vars.to_slice().rev_iter() do
    if binding.name == name then return some(binding.id)
  none[EggId]()
}
struct VisibleSnapshot { vars_len: Int }
fun snapshot(visible: Visible): _ {
  VisibleSnapshot { vars_len = visible.vars.len }
}
fun restore(visible: &Visible, snapshot: VisibleSnapshot) {
  visible.vars.len = snapshot.vars_len
}

| Converting Toast To Egg  

fun to_egg(toast: Toast): Result[Egg, Error] {
  var funs = list[EggFun]()

  for builtin in builtins do funs.&.push(builtin.create_builtin_fun())
  for def in toast.defs do
    if def is fun_(fun_) then
      funs.&.push(EggFun {
        name = fun_.name,
        params = {
          var params = list[EggParam]()
          for param in fun_.params do
            params.&.push(param.name.string / param.type.to_egg(toast)?)
          params.to_slice()
        },
        return_type = fun_.return_type.to_egg(toast)?,
        impl = EggFunImpl.code({
          var visible = visible()
          var compiler = egg_code_compiler(toast).&
          var body = compiler.egg_body_compiler().&

          for param in fun_.params do
            visible.&.define(param.name.string, body.push_param(param.name.src))
          var returned = fun_.body.to_egg(body, visible.&)?
          var body = body.finish(returned)

          EggCode { exprs = compiler.exprs.to_slice(), body }
        })
      })

  ok[Egg, Error](Egg { funs })
}

fun to_egg(type: ToastType, toast: Toast): Result[PlumType, Error] {
  type.to_egg(toast, map[String, PlumType](), list[OngoingTypeCall](), 0)
}
struct OngoingTypeCall { depth: Int, name: String, args: Slice[PlumType] }
fun to_egg(
  type: ToastType, toast: Toast, env: Map[String, PlumType],
  parent_calls: List[OngoingTypeCall], depth: Int,
): Result[PlumType, Error] {
  switch type
  case variable(variable)
    ok[PlumType, Error](
      if env.get_maybe(variable.string) is some(type)
      then type
      else PlumType.primitive(variable.string)
    )
  case call(call) {
    var name = call.name

    | Lower the arguments.
    var args = list[PlumType]()
    for arg in call.args do
      args.&.push(arg.to_egg(toast, env, parent_calls, depth)?)
    var args = args.to_slice()

    | Handle builtin types.
    if name.string == "Int" then {
      call.args.is_empty() or
        return error[PlumType, Error](error("Called Int with args", name.src))
      return ok[PlumType, Error](type_int)
    }
    if name.string == "String" then {
      call.args.is_empty() or
        return error[PlumType, Error](error("Called String with args", name.src))
      return ok[PlumType, Error](type_string)
    }
    if name.string == "Type" then {
      call.args.is_empty() or
        return error[PlumType, Error](error("Called Type with args", name.src))
      return ok[PlumType, Error](type_type)
    }
    if name.string == "Never" then {
      call.args.is_empty() or
        return return error[PlumType, Error](error("Called Never with args", name.src))
      return ok[PlumType, Error](type_never)
    }

    | Are we recursively lowering a type? If so, we need to insert a recursive
    | type instead of endlessly digging down into the type.
    for call in parent_calls do
      if call.name == name.string and call.args == args then
        return ok[PlumType, Error](PlumType.recursive(depth - call.depth))

    | Look for a user-defined type with the name.
    for def in toast.defs do
      if def is type(def) then
        if def.name.string == name.string then {
          var inner_env = map[String, PlumType]()
          def.params.len == args.len or
            return error[PlumType, Error](error(
              "Tried to instantiate {def.name.string} with {args.len} args, but it needs {def.params.len}.",
              name.src
            ))
          for both in zip(def.params.iter(), args.iter()) do
            inner_env.&.put(both.a.string, both.b)
          parent_calls.&.push(OngoingTypeCall { name = name.string, args, depth })
          var type = def.type.to_egg(toast, inner_env, parent_calls, depth)?
          parent_calls.&.pop()
          return ok[PlumType, Error](type)
        }
    return error[PlumType, Error](error("{name.string} doesn't exist.", name.src))
  }
  case struct_(struct_) {
    var fields = map[String, PlumType]()
    | TODO: check for duplicates
    for field in struct_ do
      fields.&.put(
        field.name.string,
        field.type.to_egg(toast, env, parent_calls, depth + 1)?
      )
    ok[PlumType, Error](PlumType.struct_(fields))
  }
  case enum_(enum_) {
    var variants = map[String, Slice[PlumType]]()
    for variant in enum_ do {
      var args = list[PlumType]()
      for arg in variant.args do
        args.&.push(arg.to_egg(toast, env, parent_calls, depth + 1)?)
      | TODO: check for duplicates
      variants.&.put(variant.name.string, args.to_slice())
    }
    ok[PlumType, Error](PlumType.enum_(variants))
  }
  case lambda(lambda) {
    var args = list[PlumType]()
    for arg in lambda.args do
      args.&.push(arg.to_egg(toast, env, parent_calls, depth + 1)?)
    ok[PlumType, Error](PlumType.lambda(LambdaType {
      args = args.to_slice(),
      return_type = lambda.return_type
        .to_egg(toast, env, parent_calls, depth + 1)?.put_on_heap(),
    }))
  }
}

fun create_builtin_fun(builtin: Builtin): EggFun {
  var signature = builtin.signature()
  EggFun {
    name = "builtin_{builtin}" @ invalid_src(),
    params = signature.params,
    return_type = signature.return_type,
    impl = EggFunImpl.builtin(builtin),
  }
}

struct EggCodeCompiler { toast: Toast, exprs: List[EggExpr] }
struct EggBodyCompiler {
  parent: &EggCodeCompiler, params: List[EggId], exprs: List[EggId]
}
fun egg_code_compiler(toast: Toast): _ {
  EggCodeCompiler { toast, exprs = list[EggExpr]() }
}
fun egg_body_compiler(parent: &EggCodeCompiler): _ {
  EggBodyCompiler { parent, params = list[EggId](), exprs = list[EggId]() }
}
fun finish(body: EggBodyCompiler, id: EggId): EggBody {
  EggBody {
    params = body.params.to_slice(), exprs = body.exprs.to_slice(), returns = id
  }
}
fun push_param(body: &EggBodyCompiler, src: Src): EggId {
  var id = EggId { int = body.parent.exprs.len }
  body.parent.exprs.&.push(EggExprKind.param @ src)
  body.params.&.push(id)
  id
}
fun push(body: &EggBodyCompiler, expr: EggExpr): EggId {
  var id = EggId { int = body.parent.exprs.len }
  body.parent.exprs.&.push(expr)
  body.exprs.&.push(id)
  id
}

fun to_egg(
  toast: ToastExpr, body: &EggBodyCompiler, visible: &Visible
): Result[EggId, Error] {
  ok[EggId, Error](
    switch toast
    case int(int) body.push(EggExprKind.int(int.int) @ int.src)
    case string(string) body.push(EggExprKind.string(string.string) @ string.src)
    case struct_(struct_) {
      var fields = map[String, EggId]()
      | TODO: check for duplicates
      for field in struct_.fields do
        fields.&.put(field.name.string, field.value.to_egg(body, visible)?)
      body.push(EggExprKind.struct_(fields) @ struct_.ampersand.src)
    }
    case member(member) {
      var of = member.of.to_egg(body, visible)?
      body.push(EggExprKind.member(EggMember {
        of, name = member.name.string
      }) @ member.name.src)
    }
    case symbol(symbol) body.push(EggExprKind.symbol(symbol.string) @ symbol.src)
    case switch_(switch_) {
      var condition = switch_.condition.to_egg(body, visible)?
      var cases = map[String, EggBody]()
      for case_ in switch_.cases do {
        var snapshot = visible.snapshot()
        var case_body = body.parent.egg_body_compiler().&
        for param in case_.params do
          visible.define(param.string, case_body.push_param(param.src))
        var returns = case_.body.to_egg(case_body, visible)?
        var case_body = case_body.finish(returns)
        visible.restore(snapshot)
        cases.&.put(case_.symbol.string, case_body)
      }
      body.push(
        EggExprKind.switch_(EggSwitch { condition, cases })
          @ switch_.percent.src
      )
    }
    case name(name)
      visible.lookup(name.string) or
        return error[EggId, Error](error(
          "Unknown referenced name {name.string}.", name.src
        ))
    case lambda(lambda) {
      var snapshot = visible.snapshot()
      var lambda_body = body.parent.egg_body_compiler().&
      for param in lambda.params do
        visible.define(param.name.string, lambda_body.push_param(param.name.src))
      var returns = lambda.body.to_egg(lambda_body, visible)?
      var lambda_body = lambda_body.finish(returns)
      visible.restore(snapshot)

      body.push(EggExprKind.lambda(EggLambda {
        params = {
          var params = list[EggParam]()
          for param in lambda.params do
            params.&.push(param.name.string / param.type.to_egg(body.parent.toast)?)
          params.to_slice()
        },
        body = lambda_body,
      }) @ lambda.backslash.src)
    }
    case call(call) {
      var args = list[EggId]()
      for arg in call.args do args.&.push(arg.to_egg(body, visible)?)
      var args = args.to_slice()

      body.push({
        switch call.receiver.*
        case name(name) {
          switch visible.lookup(name.string)
          case some(lambda) EggExprKind.lambda_call(EggLambdaCall { lambda, args })
          case none EggExprKind.call(EggCall { receiver = name, args })
        }
        case symbol(symbol) EggExprKind.tag(EggTag { symbol = symbol.string, args })
        default {
          var lambda = call.receiver.to_egg(body, visible)?
          EggExprKind.lambda_call(EggLambdaCall { lambda, args })
        }
      } @ call.receiver.src())
    }
    case var_(var_) {
      var name = var_.left.name or return error[EggId, Error](error(
        "Variables have to be lowercase.", var_.equal_sign.src
      ))

      var value = var_.right.to_egg(body, visible)?
      visible.define(name.string, value)
      value
    }
    case body(exprs) {
      var last = none[EggId]()
      for expr in exprs do last = some(expr.to_egg(body, visible)?)
      last or unreachable()
    }
  )
}
