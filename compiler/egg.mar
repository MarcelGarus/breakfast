| Expression-Guided Graph  

import kamin.mar

struct Egg { defs: Map[Str, EggDef] }
enum EggDef { value: EggFun, fun_: EggFun }
struct EggFun { params: Slice[Str], exprs: Slice[EggExpr], body: EggBody }
struct EggId { int: Int }

struct EggBody { exprs: Slice[EggId], returns: EggId }
enum EggExpr {
  int: Int,
  symbol: Str,
  param: Str,
  global: Str,
  switch_: EggSwitch,
  call: EggCall,
}
struct EggSwitch { condition: EggId, cases: Map[Str, EggBody] }
struct EggCall { receiver: EggId, args: Slice[EggId] }

fun ==(a: EggId, b: EggId): Bool { a.int == b.int }
fun hash(hasher: &Hasher, id: EggId) { hasher.hash(id.int) }

fun get(fun_: EggFun, id: EggId): EggExpr { fun_.exprs.get(id.int) }

fun write[W](writer: W, egg: Egg) {
  var first = true
  for def in egg.defs do {
    if first then first = false else writer."\n"
    writer."{def.key}:"
    switch def.value
    case value(fun_) {
      writer."\n"
      writer.write(fun_.body, fun_, 1)
    }
    case fun_(fun_) {
      for param in fun_.params do writer." {param}"
      writer."\n"
      writer.write(fun_.body, fun_, 1)
    }
  }
}
fun write[W](writer: W, id: EggId) { writer.":{id.int}" }
fun write[W](writer: W, body: EggBody, fun_: EggFun, indentation: Int) {
  for id in body.exprs do {
    for i in 0..indentation do writer."  "
    writer."{id} = "
    writer.write(fun_.get(id), fun_, indentation)
    writer."\n"
  }
  for i in 0..indentation do writer."  "
  writer."{body.returns}"
}
fun write[W](writer: W, expr: EggExpr, fun_: EggFun, indentation: Int) {
  switch expr
  case int(int) writer."int {int}"
  case symbol(symbol) writer."symbol {symbol}"
  case param(param) writer."param {param}"
  case global(global) writer."global {global}"
  case switch_(switch_) {
    writer."switch {switch_.condition}"
    for case_ in switch_.cases do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {case_.key}:\n"
      writer.write(case_.value, fun_, indentation + 2)
    }
  }
  case call(call) {
    writer."call {call.receiver}"
    for arg in call.args do writer." {arg}"
  }
}

| Variable Scoping  
| Tracks which names are in scope using a simple vector:
| - When new names are defined, appends items to the vector.
| - When names are referenced, walks the vector from the back, searching for the
|   name. Names that are defined later shadow previously defined names.
| - When bodies are compiled, save the length of the vector before entering the
|   body. When exiting the body, trim the vector to that length â€“ all names
|   defined inside the body automatically go out of scope.

struct Visible { vars: Vec[Tuple2[Str, NameBinding]] }
enum NameBinding { global: Str, local: EggId }
fun visible(): _ { Visible { vars = vec[Tuple2[Str, NameBinding]]() } }
fun define(visible: &Visible, name: Str, value: NameBinding) {
  visible.vars.&.push(tuple(name, value))
}
fun lookup(visible: Visible, name: Str): Maybe[NameBinding] {
  for binding in visible.vars.to_slice().rev_iter() do
    if binding.a == name then return some(binding.b)
  none[NameBinding]()
}
struct VisibleSnapshot { vars_len: Int }
fun snapshot(visible: Visible): _ {
  VisibleSnapshot { vars_len = visible.vars.len }
}
fun restore(visible: &Visible, snapshot: VisibleSnapshot) {
  visible.vars.len = snapshot.vars_len
}

| Converting Toast To Egg  

fun to_egg(toast: Toast): Egg {
  var defs = map[Str, EggDef]()
  var visible = visible()

  var body = toast.body or panic("Top-level Toast is not a body.")

  visible.&.define("builtin_add", NameBinding.global("@builtin_add"))
  for toast in body do {
    var def = toast.def or panic("top-level non-def:\n{toast}")
    visible.&.define(def.name, NameBinding.global(def.name))
  }
  for toast in body do {
    var def = toast.def.unwrap()
    var name = def.name
    var value = def.value.*
    var snapshot = visible.snapshot()
    var value =
      switch value
      case fun_(fun_) {
        var compiler = egg_fun_compiler().&
        var body = compiler.egg_body_compiler().&
        for param in fun_.params do
          visible.&.define(param, NameBinding.local(body.push(EggExpr.param(param))))
        var body = body.finish(fun_.body.to_egg(body, visible.&))
        EggDef.fun_(EggFun {
          params = fun_.params, exprs = compiler.exprs.to_slice(), body
        })
      }
      default {
        var compiler = egg_fun_compiler().&
        var body = compiler.egg_body_compiler().&
        var body = body.finish(value.to_egg(body, visible.&))
        EggDef.value(EggFun {
          params = empty_slice[Str](), exprs = compiler.exprs.to_slice(), body
        })
      }
    visible.&.restore(snapshot)
    defs.&.put(name, value)
  }

  Egg { defs }
}

struct EggFunCompiler { exprs: Vec[EggExpr] }
struct EggBodyCompiler { parent: &EggFunCompiler, exprs: Vec[EggId] }
fun egg_fun_compiler(): _ { EggFunCompiler { exprs = vec[EggExpr]() } }
fun egg_body_compiler(parent: &EggFunCompiler): _ {
  EggBodyCompiler { parent, exprs = vec[EggId]() }
}
fun finish(body: EggBodyCompiler, id: EggId): EggBody {
  EggBody { exprs = body.exprs.to_slice(), returns = id }
}
fun push(body: &EggBodyCompiler, expr: EggExpr): EggId {
  var id = EggId { int = body.parent.exprs.len }
  body.parent.exprs.&.push(expr)
  body.exprs.&.push(id)
  id
}

fun to_egg(toast: Toast, body: &EggBodyCompiler, visible: &Visible): EggId {
  switch toast
  case int(int) body.push(EggExpr.int(int))
  case symbol(symbol) body.push(EggExpr.symbol(symbol))
  case name(name) {
    switch visible.lookup(name) or panic("unknown referenced name {name}")
    case global(global) body.push(EggExpr.global(global))
    case local(local) local
  }
  case switch_(switch_) {
    var condition = switch_.condition.to_egg(body, visible)
    var cases = map[Str, EggBody]()
    for case_ in switch_.cases do {
      var case_body = body.parent.egg_body_compiler().&
      var case_body = case_body.finish(case_.body.to_egg(case_body, visible))
      cases.&.put(case_.symbol, case_body)
    }
    body.push(EggExpr.switch_(EggSwitch { condition, cases }))
  }
  case call(call) {
    var receiver = call.receiver.to_egg(body, visible)
    var args = vec[EggId]()
    for arg in call.args do args.&.push(arg.to_egg(body, visible))
    body.push(EggExpr.call(EggCall { receiver, args = args.to_slice() }))
  }
  case def(def) {
    var value = def.value.to_egg(body, visible)
    visible.define(def.name, NameBinding.local(value))
    value
  }
  case fun_(fun_) panic("non-top-level function")
  case body(exprs) {
    var last = none[EggId]()
    for expr in exprs do last = some(expr.to_egg(body, visible))
    last or panic("empty body")
  }
}
