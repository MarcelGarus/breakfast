| The Virtual Machine  
| Internally, code runs in a stack-based virtual machine (VM), something like a
| mini-computer implemented in software. The VM has its own data stack and call
| stack and operates on instructions (called byte code instructions).

import plum.mar

struct Vm {
  universe: &Universe,
  data_stack: List[ObjectId],
  call_stack: List[CallStackEntry],
}
struct CallStackEntry {
  code: ObjectId, fun_: FunId, instruction_index: Int
}

fun write[W](writer: W, vm: Vm) {
  writer."data stack:"
  for id in vm.data_stack do {
    writer." "
    writer.write_deep(id, vm.universe.*)
  }
  writer."\ncall stack:"
  for call in vm.call_stack do
    writer."\n- {vm.get(call.code).code.unwrap().get(call.fun_).name.debug()}:{call.instruction_index}"
  | writer."\ninstructions:"
  | for instruction in vm.instructions.iter().enumerate() do {
  |   var is_current = instruction.index == vm.instruction_pointer
  |   writer."\n{if is_current then ">" else " "} "
  |   writer.write(instruction.item, vm)
  | }
}

fun new(vm: &Vm, object: Object): ObjectId { vm.universe.new(object) }
fun get(vm: Vm, id: ObjectId): Object { vm.universe.get(id) }
fun push(vm: &Vm, id: ObjectId) { vm.data_stack.&.push(id) }
fun pop(vm: &Vm): ObjectId { vm.data_stack.&.pop() }
fun call(universe: &Universe, fun_: MainFun, args: Slice[ObjectId]): ObjectId {
  var vm = Vm {
    universe,
    data_stack = list[ObjectId](),
    call_stack = list[CallStackEntry](),
  }

  for arg in args do vm.&.push(arg)
  vm.call_stack.&.push(CallStackEntry {
    code = fun_.code, fun_ = fun_.id, instruction_index = 0
  })
  loop {
    var current_call = vm.call_stack.get_maybe_ref(vm.call_stack.len - 1) or {
      break
    }
    var instructions = vm.get(current_call.code).code.unwrap()
      .get(current_call.fun_).instructions
    var instruction = instructions.get_maybe(current_call.instruction_index) or {
      vm.call_stack.&.pop()
      continue
    }
    current_call.instruction_index = current_call.instruction_index + 1

    | println("running {instruction.debug()}")
    switch instruction
    case push_object(object_id) vm.&.push(object_id)
    case push_from_stack(offset) vm.&.push(vm.data_stack.get(vm.data_stack.len - 1 - offset))
    case pop_n_below_top(n) {
      var top = vm.&.pop()
      for i in 0..n do vm.&.pop()
      vm.&.push(top)
    }
    case jump(index) current_call.instruction_index = index
    case jump_table(table) {
      var symbol = vm.get(vm.data_stack.last()).tag.unwrap().symbol
      current_call.instruction_index = table.get(symbol)
    }
    case struct_(field_names) {
      var num_fields = field_names.len
      var field_values = uninitialized_slice[ObjectId](num_fields)
      for i in 0..num_fields do field_values.get_ref(num_fields - 1 - i).* = vm.&.pop()

      var fields = map[String, ObjectId]()
      for field in zip(field_names.iter(), field_values.iter()) do
        fields.&.put(field.a, field.b)
      vm.&.push(vm.&.new(Object.struct_(fields)))
    }
    case member(name) {
      var field = vm.get(vm.&.pop()).struct_.unwrap().get(name)
      vm.&.push(field)
    }
    case tag(tag) {
      var symbol = tag.a
      var num_args = tag.b
      var args = uninitialized_slice[ObjectId](num_args)
      for i in 0..num_args do args.get_ref(num_args - 1 - i).* = vm.&.pop()
      vm.&.push(vm.&.new(Object.tag(TagObject{ symbol, args })))
    }
    case untag {
      var tag = vm.get(vm.&.pop()).tag.unwrap()
      for arg in tag.args do vm.&.push(arg)
    }
    case call(fun_)
      vm.call_stack.&.push(CallStackEntry {
        code = current_call.code, fun_, instruction_index = 0
      })
    case add_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(a + b)))
    }
    case sub_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(a - b)))
    }
    case mul_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(a * b)))
    }
    case div_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(a / b)))
    }
    case mod_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(a % b)))
    }
    case and_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(a & b)))
    }
    case or_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(or(a, b))))
    }
    case xor_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.int(a ^ b)))
    }
    case compare_ints {
      var b = vm.get(vm.&.pop()).int.unwrap()
      var a = vm.get(vm.&.pop()).int.unwrap()
      vm.&.push(vm.&.new(Object.tag(TagObject {
        symbol =
          switch a <=> b
          case less "Less"
          case equal "Equal"
          case greater "Greater",
        args = empty_slice[ObjectId]()
      })))
    }
    case concat_strings {
      var b = vm.get(vm.&.pop()).string.unwrap()
      var a = vm.get(vm.&.pop()).string.unwrap()
      vm.&.push(vm.&.new(Object.string("{a}{b}")))
    }
    case crash {
      var msg = vm.get(vm.&.pop()).string.unwrap()
      panic("VM crashed: {msg}")
    }
  }

  vm.data_stack.len == 1 or panic("more than one return value on the data stack")
  vm.data_stack.get(0)
}
