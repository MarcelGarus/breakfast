| Blocks Arranged by COlumn Nesting  
| A tree that represents the file content structured by indentation. Each line
| maps to a node/"block" in that tree. Some leading characters like | and % also
| introduce new blocks that don't correspond to a line.

import breakfast.mar

struct Bacon { line: String, children: Slice[Bacon] }

fun write[W](writer: W, bacon: Bacon) { writer.write(bacon.children, 0) }
fun write[W](writer: W, bacon: Bacon, indentation: Int) {
  for i in 0..indentation do writer."  "
  writer."{bacon.line}"
  if bacon.children.is_not_empty() then writer."\n"
  writer.write(bacon.children, indentation + 1)
}
fun write[W](writer: W, bacons: Slice[Bacon], indentation: Int) {
  var first = true
  for bacon in bacons do {
    if first then first = false else writer."\n"
    writer.write(bacon, indentation)
  }
}

struct OngoingBacon {
  indentation: Int,
  line: String,
  children: List[OngoingBacon],
}

fun to_bacon(bacon: OngoingBacon): Bacon {
  var children = list[Bacon]()
  for child in bacon.children do children.&.push(child.to_bacon())
  Bacon { line = bacon.line, children = children.to_slice() }
}
fun to_bacon(content: String): Bacon {
  var root = OngoingBacon {
    indentation = -1, line = "", children = list[OngoingBacon]()
  }
  for line in content.lines() do {
    if line.trim().is_empty() then continue
    var indentation = 0
    loop {
      line.chars().get(indentation) == space or break
      indentation = indentation + 1
    }
    var node = root.&
    loop {
      var last_child = node.children.&.get_maybe_ref(node.children.len - 1)
        or break
      if last_child.indentation >= indentation then break
      node = last_child
    }
    line = line.trim()
    var first_char = line.chars().get(0)
    var create_extra_block = first_char == #% or first_char == #|
    node.children.&.push(
      if create_extra_block then
        OngoingBacon {
          indentation, line = "{first_char}",
          children =
            if line.without_first(1).trim().is_empty() then
              list[OngoingBacon]()
            else
              list(OngoingBacon {
                indentation = indentation + 2,
                line = line.without_first(1).trim(),
                children = list[OngoingBacon](),
              })
        }
      else
        OngoingBacon {
          indentation, line = line.trim(), children = list[OngoingBacon]()
        }
    )
  }

  root.to_bacon()
}
