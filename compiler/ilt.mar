| Indented Lines Tree  
| A tree that contains all the lines of a file, structured by their indentation.

import kamin.mar

struct Ilt {
  line: Str,
  children: Slice[Ilt],
}

fun write[W](writer: W, ilt: Ilt) { writer.write(ilt.children, 0) }
fun write[W](writer: W, ilt: Ilt, indentation: Int) {
  for i in 0..indentation do writer."  "
  writer."{ilt.line}"
  if ilt.children.is_not_empty() then writer."\n"
  writer.write(ilt.children, indentation + 1)
}
fun write[W](writer: W, ilts: Slice[Ilt], indentation: Int) {
  var first = true
  for ilt in ilts do {
    if first then first = false else writer."\n"
    writer.write(ilt, indentation)
  }
}

struct OngoingIlt {
  indentation: Int,
  line: Str,
  children: Vec[OngoingIlt],
}

fun to_ilt(ilt: OngoingIlt): Ilt {
  var children = vec[Ilt]()
  for child in ilt.children do children.&.push(child.to_ilt())
  Ilt { line = ilt.line, children = children.to_slice() }
}
fun to_ilt(content: Str): Ilt {
  var root = OngoingIlt {
    indentation = -1, line = "", children = vec[OngoingIlt]()
  }
  for line in content.lines() do {
    if line.trim().is_empty() then continue
    var indentation = 0
    loop {
      line.chars().get(indentation) == space or break
      indentation = indentation + 1
    }
    var node = root.&
    loop {
      var last_child = node.children.&.get_maybe_ref(node.children.len - 1)
        or break
      if last_child.indentation >= indentation then break
      node = last_child
    }
    node.children.&.push(OngoingIlt {
      indentation, line = line.trim(), children = vec[OngoingIlt]()
    })
  }

  root.to_ilt()
}
