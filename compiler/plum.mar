import ../../martinaise/stdlib.mar
import error.mar
import formatting.mar
import type.mar
import builtins.mar
import bacon.mar
import toast.mar
import egg.mar
import yogurt.mar
| import universe.mar
import vm.mar

| Compiler Stages:
| - Bacon
| - Toast
| - Egg
| - Yogurt
| - Byte Code in the universe of objects

fun main(): Never {
  eprintln("Welcome to the Plum compiler!")

  var content = read_file("test.plum") or {
    eprintln("Couldn't read file")
    exit(1)
  }
  var content = content.to_string()

  var bacon = content.to_bacon()
  | println("Bacon:\n{bacon}\n")

  var toast = bacon.to_toast() or(error) {
    stderr."Oh no! An error occurred:\n\n{error}\n"
    exit(1)
  }
  | println("Toast:\n{toast}\n")

  var egg = toast.to_egg() or(error) {
    stderr."Oh no! An error occurred:\n\n{error}\n"
    exit(1)
  }
  println("Egg:\n{egg}\n")

  var yogurt = egg.to_yogurt() or(error) {
    stderr."Oh no! An error occurred:\n\n{error}\n"
    exit(1)
  }
  eprintln("Yogurt:\n{yogurt}\n")

  | var c = yogurt.to_c()
  | write_file("test.c", c.code.bytes())
  | eprintln("\nWrote C code to test.c")

  var hello = "Hello, panic!"
  var byte_code = uninitialized_slice[ByteCodeInstruction](10)
  byte_code.&.get_ref(0).* = ByteCodeInstruction.push_64(hello.len)
  byte_code.&.get_ref(1).* = ByteCodeInstruction.push_64(hello.data.cast[Address, Int]())
  byte_code.&.get_ref(2).* = ByteCodeInstruction.crash
  byte_code.&.get_ref(3).* = ByteCodeInstruction.push_64_from_stack(0)
  byte_code.&.get_ref(4).* = ByteCodeInstruction.push_8(42.lower_byte())
  byte_code.&.get_ref(5).* = ByteCodeInstruction.store_8
  byte_code.&.get_ref(6).* = ByteCodeInstruction.load_8
  byte_code.&.get_ref(7).* = ByteCodeInstruction.ret

  var result = byte_code.data.call(empty_slice[Byte]())
  var result = result.data.to_reference[Address]().*.to_reference[Int]().*
  print("Result: {result.radix(16)}")
  | for byte in result do print(" {byte}")
  println()

  | eprintln("Compiling to byte code")
  | var universe = big_bang()
  | var main = yogurt.compile(universe.&)
  | | eprintln("Compiled to byte code:\n{universe}")

  | eprintln("Running")
  | var five = universe.&.new(Object.int(5))
  | var return_value = universe.&.call(main, list(five).to_slice())
  | stdout.write_deep(return_value, universe)
  | println()
  | println(universe)

  exit(0)
}
